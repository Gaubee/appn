import{z as m,N as y,_ as q,b as j,f as Q}from"./css-color-mix-CkVeYiGO.js";import{e as $}from"./my-element-CSfgff9r.js";Promise.withResolvers||(Promise.withResolvers=function(){let e,t;return{promise:new this((r,s)=>{e=r,t=s}),resolve:e,reject:t}});const A=Promise.withResolvers.bind(Promise);class z extends Event{#t;constructor(t){if(super("navigate",t),!t)throw new TypeError("init required");if(!t.destination)throw new TypeError("destination required");if(!t.signal)throw new TypeError("signal required");this.#t={canIntercept:t.canIntercept??!1,destination:t.destination,downloadRequest:t.downloadRequest||null,formData:t.formData||null,hasUAVisualTransition:!1,hashChange:t.hashChange??!1,info:t.info,signal:t.signal,userInitiated:t.userInitiated??!1,navigationType:t.navigationType??"push"}}async __runHandler(){const t=this.#n;typeof t=="function"&&await t.call(this),this.#e,this.#r}get navigationType(){return this.#t.navigationType}get canIntercept(){return this.#t.canIntercept}get canTransition(){return this.#t.canIntercept}get userInitiated(){return this.#t.userInitiated}get hashChange(){return this.#t.hashChange}get hasUAVisualTransition(){return this.#t.hasUAVisualTransition}get destination(){return this.#t.destination}get signal(){return this.#t.signal}get formData(){return this.#t.formData}get downloadRequest(){return this.#t.downloadRequest}get info(){return this.#t.info}#n;#e;#r;intercept(t){t&&(this.#n=t.handler,this.#e=t.focusReset,this.#r=t.scroll)}scroll(){}}class H extends Event{__init;constructor(t){super("currententrychange",t),this.__init=t}get navigationType(){return this.__init.navigationType??null}get from(){return this.__init.from}}class G{__init;get id(){return this.__init.id}get index(){return this.__init.index}get key(){return this.__init.key}get sameDocument(){return!0}get url(){return this.__init.url}getState(){return this.__init.state}constructor(t){this.__init=t}}let E=(()=>{let e=EventTarget,t,n=[],r=[];return class extends e{static{const i=typeof Symbol=="function"&&Symbol.metadata?Object.create(e[Symbol.metadata]??null):void 0;t=[$()],q(this,null,t,{kind:"accessor",name:"ondispose",static:!1,private:!1,access:{has:o=>"ondispose"in o,get:o=>o.ondispose,set:(o,a)=>{o.ondispose=a}},metadata:i},n,r),i&&Object.defineProperty(this,Symbol.metadata,{enumerable:!0,configurable:!0,writable:!0,value:i})}__init;get id(){return this.__init.id}get index(){return this.__init.index}get key(){return this.__init.key}get sameDocument(){return!0}get url(){return this.__init.url}get __debug(){return`${this.index}/${this.id.split("-")[0]}/${this.key.split("-")[0]}`}getState(){return this.__init.state}__getInit(){return this.__init}__setInit(i){this.__init=i}#t=j(this,n,void 0);get ondispose(){return this.#t}set ondispose(i){this.#t=i}constructor(i){super(),j(this,r),this.__init=i}}})();class J{__init;constructor(t){this.__init=t}get navigationType(){return this.__init.navigationType}get from(){return this.__init.from}get finished(){return this.__init.finished}}const T=(e,t)=>t.some(n=>e instanceof n);let L,R;function X(){return L||(L=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Y(){return R||(R=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const M=new WeakMap,x=new WeakMap,b=new WeakMap;function Z(e){const t=new Promise((n,r)=>{const s=()=>{e.removeEventListener("success",i),e.removeEventListener("error",o)},i=()=>{n(g(e.result)),s()},o=()=>{r(e.error),s()};e.addEventListener("success",i),e.addEventListener("error",o)});return b.set(t,e),t}function tt(e){if(M.has(e))return;const t=new Promise((n,r)=>{const s=()=>{e.removeEventListener("complete",i),e.removeEventListener("error",o),e.removeEventListener("abort",o)},i=()=>{n(),s()},o=()=>{r(e.error||new DOMException("AbortError","AbortError")),s()};e.addEventListener("complete",i),e.addEventListener("error",o),e.addEventListener("abort",o)});M.set(e,t)}let k={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return M.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return g(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function K(e){k=e(k)}function et(e){return Y().includes(e)?function(...t){return e.apply(B(this),t),g(this.request)}:function(...t){return g(e.apply(B(this),t))}}function nt(e){return typeof e=="function"?et(e):(e instanceof IDBTransaction&&tt(e),T(e,X())?new Proxy(e,k):e)}function g(e){if(e instanceof IDBRequest)return Z(e);if(x.has(e))return x.get(e);const t=nt(e);return t!==e&&(x.set(e,t),b.set(t,e)),t}const B=e=>b.get(e);function rt(e,t,{blocked:n,upgrade:r,blocking:s,terminated:i}={}){const o=indexedDB.open(e,t),a=g(o);return r&&o.addEventListener("upgradeneeded",c=>{r(g(o.result),c.oldVersion,c.newVersion,g(o.transaction),c)}),n&&o.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),a.then(c=>{i&&c.addEventListener("close",()=>i()),s&&c.addEventListener("versionchange",d=>s(d.oldVersion,d.newVersion,d))}).catch(()=>{}),a}const st=["get","getKey","getAll","getAllKeys","count"],it=["put","add","delete","clear"],D=new Map;function U(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(D.get(t))return D.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,s=it.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(s||st.includes(n)))return;const i=async function(o,...a){const c=this.transaction(o,s?"readwrite":"readonly");let d=c.store;return r&&(d=d.index(a.shift())),(await Promise.all([d[n](...a),s&&c.done]))[0]};return D.set(t,i),i}K(e=>({...e,get:(t,n,r)=>U(t,n)||e.get(t,n,r),has:(t,n)=>!!U(t,n)||e.has(t,n)}));const ot=["continue","continuePrimaryKey","advance"],O={},C=new WeakMap,N=new WeakMap,at={get(e,t){if(!ot.includes(t))return e[t];let n=O[t];return n||(n=O[t]=function(...r){C.set(this,N.get(this)[t](...r))}),n}};async function*ct(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,at);for(N.set(n,t),b.set(n,B(t));t;)yield n,t=await(C.get(n)||t.continue()),C.delete(n)}function F(e,t){return t===Symbol.asyncIterator&&T(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&T(e,[IDBIndex,IDBObjectStore])}K(e=>({...e,get(t,n,r){return F(t,n)?ct:e.get(t,n,r)},has(t,n){return F(t,n)||e.has(t,n)}}));const I=await rt("appn-navigation",1,{upgrade(e){e.createObjectStore("entries",{keyPath:"key"}).createIndex("sessionKey","sessionKey")}}),V="--appn-navigation-session-key--",v=history.state?.sessionKey??sessionStorage.getItem(V)??crypto.randomUUID();sessionStorage.setItem(V,v);const ut=async()=>{const e=I.transaction("entries"),n=await e.objectStore("entries").index("sessionKey").getAll(v);return e.commit(),n.sort((r,s)=>r.index-s.index)},p=async e=>{const t=I.transaction("entries","readwrite");await t.objectStore("entries").put(e),await t.commit()},W=async e=>{const t=I.transaction("entries","readwrite"),n=t.objectStore("entries");await n.clear();for(const r of e)await n.add(r);await t.commit()},S=async e=>W(e.map(t=>t.__getInit())),dt=async e=>{const t=I.transaction("entries","readwrite");await t.objectStore("entries").add(e),await t.commit()},_=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,ht=Q(async()=>{let t=(await ut()).map(s=>new E(s));const n=history.state?.id;let r=n&&_.test(n)?t.find(s=>s.id===n):void 0;if(!r){const s={id:crypto.randomUUID(),index:0,key:crypto.randomUUID(),url:location.href,state:void 0,sessionKey:v};r=new E(s),t=[r],history.replaceState(s,"",s.url),W([s])}return{entries:t,currentEntry:r}});class f extends EventTarget{#t;constructor(t){super(),this.#t=t,window.addEventListener("popstate",async n=>{console.log("QAQ popstate",n.state),m(n.state).with({id:y.string.regex(_),index:y.number.gte(0),key:y.string.regex(_),url:y.string.startsWith(location.origin),state:y.any,sessionKey:y.string.regex(_)},r=>{if(r.id===t.currentEntry.id){console.log("QAQ popstate","traverseTo ignore");return}console.log("QAQ popstate","traverseTo start"),this.traverseTo(r.key,{info:n})}).otherwise(()=>{})})}entries(){return this.#t.entries}get currentEntry(){return this.#t.currentEntry}updateCurrentEntry(t){const n=this.#t.currentEntry;history.replaceState({...n.__getInit(),state:t.state},"",location.href);const r=history.state;n.__setInit(r),p(r)}#n=null;get transition(){return this.#n}get canGoBack(){const{currentEntry:t}=this,n=this.entries();return!t||n.length===0?!1:t.index>n.at(0).index}get canGoForward(){const{currentEntry:t}=this,n=this.entries();return!t||n.length===0?!1:t.index<n.at(-1).index}navigate(t,n){const s=new URL(t,document.baseURI).href,i=m(n?.history).with("push","replace",P=>P).otherwise(()=>s===location.href?"replace":"push"),o=new w,a=this.#t.currentEntry,c=a.index,d={id:crypto.randomUUID(),index:m(i).with("push",()=>c+1).with("replace",()=>c).exhaustive(),key:crypto.randomUUID(),url:s,state:n?.state,sessionKey:v};return f.#e(this,o,a,d,i,n?.info),o.result}reload(t){const n="reload",r=new w,s=this.#t.currentEntry,i=t?.state===void 0?s:{...s.__getInit(),state:t?.state};return f.#e(this,r,s,i,n,t?.info),r.result}traverseTo(t,n){const r=this.#t.entries.find(i=>i.key===t),s=new w;if(r===this.currentEntry)s.committer.resolve(r),s.finisher.resolve(r);else if(!r)s.abort.abort(new DOMException("Invalid key","InvalidStateError"));else{const i="traverse",o=this.#t.currentEntry;f.#e(this,s,o,r,i,n?.info)}return s.result}back(t){const n="traverse",r=new w,s=this.#t.currentEntry,i=this.#t.entries,o=i[i.indexOf(s)-1];return o?f.#e(this,r,s,o,n,t?.info):r.abort.abort(new DOMException("Cannot go back","InvalidStateError")),r.result}forward(t){throw new Error("Method not implemented.")}static#e(t,n,r,s,i,o){let a,c;s instanceof E?(c=s,a=s.__getInit()):a=s;const d=new z({navigationType:i,canIntercept:!0,hashChange:new URL(a.url).hash!==new URL(r.url).hash,destination:new G(a),signal:n.abort.signal,formData:null,downloadRequest:null,info:o});if(t.dispatchEvent(d)){const h=c??new E(a);t.#t.currentEntry=h;const u=t.#t.entries;n.committer.resolve(h),m(i).with("push",()=>{history.pushState(a,"",a.url||location.href);const l=u.indexOf(r)+1;l===0?(u.length=0,u.push(h),S(u)):l===u.length?(u.push(h),dt(a)):(u.splice(l,u.length-l,h),S(u))}).with("replace",()=>{history.replaceState(a,"",a.url||location.href);const l=u.indexOf(r);l===-1?(u.length=0,u.push(h),S(u)):(u[l]=h,p(a))}).with("traverse",()=>{o instanceof PopStateEvent||history.go(a.index-r.index),p(a)}).with("reload",async()=>{h.getState()!==r.getState()&&await p(a),location.reload()}).exhaustive(),t.dispatchEvent(new H({navigationType:i,from:r})),(async()=>{try{t.#n=new J({navigationType:i,from:r,finished:n.finisher.promise.then(()=>{})}),await d.__runHandler(),n.finisher.resolve(h)}catch(l){n.finisher.reject(l)}t.#n=null})()}else{const h=new DOMException("Navigation was aborted","AbortError");n.abort.abort(h)}}}const lt=new f(await ht());Object.assign(globalThis,{minNavigation:lt,MinNavigation:f});class w{committer=A();finisher=A();abort=new AbortController;result={committed:this.committer.promise,finished:this.finisher.promise};constructor(){const t=this.abort;t.signal.addEventListener("abort",()=>{this.committer.reject(t.signal.reason),this.finisher.reject(t.signal.reason)})}}export{z as MinNavigateEvent,f as MinNavigation,H as MinNavigationCurrentEntryChangeEvent,G as MinNavigationDestination,E as MinNavigationHistoryEntry,J as MinNavigationTransition,lt as navigation};
