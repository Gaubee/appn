const n=e=>e,f=e=>Symbol.iterator in e?e:{[Symbol.iterator](){return e}},l=n((e,t)=>{o(t);const s=new Set(e);for(const r of f(t.keys()))s.add(r);return s}),a=n((e,t)=>{o(t);let s,r;e.size<=t.size?(s=e,r=t):(s=t.keys(),r=e);const i=new Set;for(const c of f(s))r.has(c)&&i.add(c);return i}),m=n((e,t)=>{o(t);const s=new Set(e);if(e.size<=t.size)for(const r of e)t.has(r)&&s.delete(r);else for(const r of f(t.keys()))s.has(r)&&s.delete(r);return s}),y=n((e,t)=>{o(t);const s=new Set(e);for(const r of f(t.keys()))e.has(r)?s.delete(r):s.add(r);return s}),_=n((e,t)=>{o(t);for(const s of e)if(!t.has(s))return!1;return!0}),d=n((e,t)=>{o(t);for(const s of f(t.keys()))if(!e.has(s))return!1;return!0}),w=n((e,t)=>{if(o(t),e.size<=t.size){for(const s of e)if(t.has(s))return!1}else for(const s of f(t.keys()))if(e.has(s))return!1;return!0});function o(e){if(!u(e))throw new TypeError;const t=e.size,s=Number(t);if(Number.isNaN(s))throw new TypeError;if(typeof e.has!="function")throw new TypeError;if(typeof e.keys!="function")throw new TypeError}function u(e){if(e===null)return!1;const t=typeof e;return t==="object"||t==="function"}export{m as set_difference,a as set_intersection,w as set_is_disjoint_from,_ as set_is_subset_of,d as set_is_superset_of,y as set_symmetric_difference,l as set_union};
