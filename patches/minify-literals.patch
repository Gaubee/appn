diff --git a/dist/index.cjs b/dist/index.cjs
index de23e3cba6ed74eaeb8496531b871bd33952fbb9..770bf5b1531a13eb4b4651c40afa581939d8da7a 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -28,21 +28,22 @@ var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__ge
 var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // lib/index.ts
-var lib_exports = {};
-__export(lib_exports, {
+var index_exports = {};
+__export(index_exports, {
   defaultGenerateSourceMap: () => defaultGenerateSourceMap,
   defaultShouldMinify: () => defaultShouldMinify,
   defaultShouldMinifyCSS: () => defaultShouldMinifyCSS,
   defaultValidation: () => defaultValidation,
   minifyHTMLLiterals: () => minifyHTMLLiterals
 });
-module.exports = __toCommonJS(lib_exports);
+module.exports = __toCommonJS(index_exports);
 var import_magic_string = __toESM(require("magic-string"), 1);
 var import_parse_literals = require("parse-literals");
 
 // lib/strategy.ts
 var import_clean_css = __toESM(require("clean-css"), 1);
 var import_html_minifier_terser = require("html-minifier-terser");
+var import_node_crypto = require("crypto");
 var defaultMinifyCSSOptions = {};
 var defaultMinifyOptions = {
   caseSensitive: true,
@@ -59,7 +60,52 @@ var defaultMinifyOptions = {
   useShortDoctype: true
 };
 var defaultStrategy = {
-  getPlaceholder(parts) {
+  getPlaceholder(parts, tag) {
+    const isCss = tag?.toLowerCase().includes("css");
+    if (isCss) {
+      const random = `tmp_${(0, import_node_crypto.randomBytes)(6).toString("hex")}`;
+      const placeholder2 = [];
+      const comment = /\/\*[\s\S]*?\*\//g;
+      for (let i = 1; i < parts.length; i++) {
+        const beforeFull = parts[i - 1].text;
+        const beforeCss = beforeFull.replace(comment, "");
+        const afterFull = parts[i].text;
+        const afterCss = afterFull.replace(comment, "");
+        const isSelector = /^\s*\{/.test(afterCss);
+        if (isSelector) {
+          placeholder2.push(`#${random}`);
+          continue;
+        }
+        const isKey = /^\s*:/.test(afterCss);
+        if (isKey) {
+          placeholder2.push(`--${random}`);
+          continue;
+        }
+        const isRule = /\}\s*$/.test(beforeCss) || beforeCss.trim().length === 0;
+        if (isRule) {
+          return `@${random}();`;
+        }
+        const isUnit = /^\w+/.test(afterCss);
+        if (isUnit) {
+          let num;
+          while (true) {
+            num = `${(0, import_node_crypto.randomInt)(281474976710655)}`;
+            if (!beforeFull.includes(num)) {
+              break;
+            }
+          }
+          placeholder2.push(num);
+          continue;
+        }
+        const isValue = /:\s*$/.test(beforeCss);
+        if (isValue) {
+          placeholder2.push(`var(--${random})`);
+          continue;
+        }
+        placeholder2.push(`var(--${random})`);
+      }
+      return placeholder2;
+    }
     const suffix = "();";
     let placeholder = "@TEMPLATE_EXPRESSION";
     while (parts.some((part) => part.text.includes(placeholder + suffix))) {
@@ -68,7 +114,10 @@ var defaultStrategy = {
     return placeholder + suffix;
   },
   combineHTMLStrings(parts, placeholder) {
-    return parts.map((part) => part.text).join(placeholder);
+    if (typeof placeholder === "string") {
+      return parts.map((part) => part.text).join(placeholder);
+    }
+    return parts.map((part, i) => part.text + (placeholder[i] ?? "")).join("");
   },
   async minifyHTML(html, options = {}) {
     let minifyCSSOptions;
@@ -124,10 +173,8 @@ var defaultStrategy = {
       ...adjustedOptions,
       returnPromise: true
     }).minify(css);
-    if (output.errors?.length)
-      throw new Error(output.errors.join("\n\n"));
-    if (output.warnings?.length)
-      console.log(css, output.styles);
+    if (output.errors?.length) throw new Error(output.errors.join("\n\n"));
+    if (output.warnings?.length) console.log(css, output.styles);
     if (output.warnings.length) {
       console.warn(output.warnings.join("\n\n"));
       console.warn(
@@ -140,12 +187,28 @@ var defaultStrategy = {
     return output.styles;
   },
   splitHTMLByPlaceholder(html, placeholder) {
-    const parts = html.split(placeholder);
-    if (placeholder.endsWith(";")) {
-      const withoutSemicolon = placeholder.substring(0, placeholder.length - 1);
-      for (let i = parts.length - 1; i >= 0; i--) {
-        parts.splice(i, 1, ...parts[i]?.split(withoutSemicolon) ?? []);
+    let parts;
+    if (typeof placeholder === "string") {
+      parts = html.split(placeholder);
+      if (placeholder.endsWith(";")) {
+        const withoutSemicolon = placeholder.substring(0, placeholder.length - 1);
+        for (let i = parts.length - 1; i >= 0; i--) {
+          parts.splice(i, 1, ...parts[i]?.split(withoutSemicolon) ?? []);
+        }
+      }
+    } else {
+      parts = [];
+      let pos = 0;
+      let index = -1;
+      for (const ph of placeholder) {
+        index = html.indexOf(ph, pos);
+        if (index === -1) {
+          throw new Error(`placeholder ${ph} not found in html ${html}`);
+        }
+        parts.push(html.slice(pos, index));
+        pos = index + ph.length;
       }
+      parts.push(html.slice(pos));
     }
     return parts;
   }
@@ -155,8 +218,7 @@ function adjustMinifyCSSOptions(options = {}) {
   const plugin = {
     level1: {
       value: (_name, value) => {
-        if (!value.startsWith("@TEMPLATE_EXPRESSION") || value.endsWith(";"))
-          return value;
+        if (!value.startsWith("@TEMPLATE_EXPRESSION") || value.endsWith(";")) return value;
         return `${value};`;
       }
     }
@@ -201,15 +263,18 @@ function defaultShouldMinify(template) {
   return !!tag && (tag.includes("html") || tag.includes("svg"));
 }
 function defaultShouldMinifyCSS(template) {
-  if (!template?.tag?.toLowerCase().includes("css"))
-    return false;
+  if (!template?.tag?.toLowerCase().includes("css")) return false;
   return true;
 }
 var defaultValidation = {
   ensurePlaceholderValid(placeholder) {
-    if (typeof placeholder !== "string" || !placeholder.length) {
-      throw new Error("getPlaceholder() must return a non-empty string");
+    if (typeof placeholder === "string" && placeholder.length > 0) {
+      return;
     }
+    if (Array.isArray(placeholder) && placeholder.every((ph) => ph.length > 0)) {
+      return;
+    }
+    throw new Error("getPlaceholder() must return a non-empty string | string[]");
   },
   ensureHTMLPartsValid(parts, htmlParts) {
     if (parts.length !== htmlParts.length) {
@@ -251,15 +316,13 @@ async function minifyHTMLLiterals(source, options = {}) {
     );
     skipHTML = true;
   }
-  if (!options.MagicString)
-    throw new Error("MagicString is required, this should never happen");
+  if (!options.MagicString) throw new Error("MagicString is required, this should never happen");
   const ms = new options.MagicString(source);
   const promises = templates.map(async (template) => {
     const minifyHTML = !skipHTML && shouldMinify(template);
     const minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);
-    if (!(minifyHTML || minifyCSS))
-      return;
-    const placeholder = strategy.getPlaceholder(template.parts);
+    if (!(minifyHTML || minifyCSS)) return;
+    const placeholder = strategy.getPlaceholder(template.parts, template.tag);
     if (validate) {
       validate.ensurePlaceholderValid(placeholder);
     }
@@ -279,8 +342,7 @@ async function minifyHTMLLiterals(source, options = {}) {
       min = await strategy.minifyHTML(combined, options.minifyOptions);
     }
     const minParts = strategy.splitHTMLByPlaceholder(min, placeholder);
-    if (validate)
-      validate.ensureHTMLPartsValid(template.parts, minParts);
+    if (validate) validate.ensureHTMLPartsValid(template.parts, minParts);
     for (const [index, part] of template.parts.entries()) {
       if (part.start < part.end)
         ms.overwrite(part.start, part.end, minParts[index] ?? "");
@@ -288,8 +350,7 @@ async function minifyHTMLLiterals(source, options = {}) {
   });
   await Promise.all(promises);
   const sourceMin = ms.toString();
-  if (source === sourceMin)
-    return null;
+  if (source === sourceMin) return null;
   let map;
   if (options.generateSourceMap !== false) {
     const generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;
diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index c36083ee21af3a923f7df7f6113ae76c172d3633..4fa0b2c533d2f384610e1e51b75bd64a2e3b61b5 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../lib/index.ts","../lib/strategy.ts"],"sourcesContent":["import MagicString, { type SourceMapOptions } from \"magic-string\";\nimport { type Template, type TemplatePart, type ParseLiteralsOptions, parseLiterals } from \"parse-literals\";\nimport { type Strategy, defaultMinifyOptions, defaultStrategy } from \"./strategy.js\";\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport type Options = DefaultOptions | CustomOptions<any>;\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using default html-minifier\n * strategy.\n */\nexport interface DefaultOptions extends BaseOptions {\n\t/**\n\t * <code>html-minifier</code> options to use. Defaults to\n\t * <code>defaultMinifyOptions</code>, for production-ready minification.\n\t */\n\tminifyOptions?: Partial<typeof defaultMinifyOptions>;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using a custom strategy.\n */\nexport interface CustomOptions<S extends Strategy> extends BaseOptions {\n\t/**\n\t * HTML minification options.\n\t */\n\tminifyOptions?: S extends Strategy<infer O> ? Partial<O> : never;\n\t/**\n\t * Override the default strategy for how to minify HTML. The default is to\n\t * use <code>html-minifier</code>.\n\t */\n\tstrategy: S;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport interface BaseOptions {\n\t/**\n\t * The name of the file. This is used to determine how to parse the source\n\t * code and for source map filenames. It may be a base name, relative, or\n\t * absolute path.\n\t */\n\tfileName?: string;\n\t/**\n\t * Override how source maps are generated. Set to false to disable source map\n\t * generation.\n\t *\n\t * @param ms the MagicString instance with code modifications\n\t * @param fileName the name or path of the file\n\t * @returns a v3 SourceMap or undefined\n\t */\n\tgenerateSourceMap?: ((ms: MagicStringLike, fileName: string) => SourceMap | undefined) | false;\n\t/**\n\t * The MagicString-like constructor to use. MagicString is used to replace\n\t * strings and generate source maps.\n\t *\n\t * Override if you want to set your own version of MagicString or change how\n\t * strings are overridden. Use <code>generateSourceMap</code> if you want to\n\t * change how source maps are created.\n\t */\n\tMagicString?: { new (source: string): MagicStringLike };\n\t/**\n\t * Override how template literals are parsed from a source string.\n\t */\n\tparseLiterals?: typeof parseLiterals;\n\t/**\n\t * Options for <code>parseLiterals()</code>.\n\t */\n\tparseLiteralsOptions?: Partial<ParseLiteralsOptions>;\n\t/**\n\t * Determines whether or not a template should be minified. The default is to\n\t * minify all tagged template whose tag name contains \"html\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinify?(template: Template): boolean;\n\t/**\n\t * Determines whether or not a CSS template should be minified. The default is\n\t * to minify all tagged template whose tag name contains \"css\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinifyCSS?(template: Template): boolean;\n\t/**\n\t * Override custom validation or set to false to disable validation. This is\n\t * only useful when implementing your own strategy that may return\n\t * unexpected results.\n\t */\n\tvalidate?: Validation | false;\n}\n\n/**\n * A MagicString-like instance. <code>minify-literals</code> only uses a\n * subset of the MagicString API to overwrite the source code and generate\n * source maps.\n */\nexport interface MagicStringLike {\n\tgenerateMap(options?: Partial<SourceMapOptions>): SourceMap;\n\toverwrite(start: number, end: number, content: string): any;\n\ttoString(): string;\n}\n\n/**\n * A v3 SourceMap.\n *\n * <code>magic-string> incorrectly declares the SourceMap type with a version\n * string instead of a number, so <code>minify-literals</code> declares\n * its own type.\n */\nexport interface SourceMap {\n\tversion: number | string;\n\tfile: string | null;\n\tsources: Array<string | null>;\n\tsourcesContent: Array<string | null>;\n\tnames: string[];\n\tmappings: string;\n\ttoString(): string;\n\ttoUrl(): string;\n}\n\n/**\n * Validation that is executed when minifying HTML to ensure there are no\n * unexpected errors. This is to alleviate hard-to-troubleshoot errors such as\n * undefined errors.\n */\nexport interface Validation {\n\t/**\n\t * Throws an error if <code>strategy.getPlaceholder()</code> does not return\n\t * a valid placeholder string.\n\t *\n\t * @param placeholder the placeholder to check\n\t */\n\tensurePlaceholderValid(placeholder: any): void;\n\t/**\n\t * Throws an error if <code>strategy.splitHTMLByPlaceholder()</code> does not\n\t * return an HTML part string for each template part.\n\t *\n\t * @param parts the template parts that generated the strings\n\t * @param htmlParts the split HTML strings\n\t */\n\tensureHTMLPartsValid(parts: TemplatePart[], htmlParts: string[]): void;\n}\n\n/**\n * The result of a call to <code>minifyHTMLLiterals()</code>.\n */\nexport interface Result {\n\t/**\n\t * The minified code.\n\t */\n\tcode: string;\n\t/**\n\t * Optional v3 SourceMap for the code.\n\t */\n\tmap?: SourceMap | undefined;\n}\n\n/**\n * The default method to generate a SourceMap. It will generate the SourceMap\n * from the provided MagicString instance using \"fileName.map\" as the file and\n * \"fileName\" as the source.\n *\n * @param ms the MagicString instance with code modifications\n * @param fileName the name of the source file\n * @returns a v3 SourceMap\n */\nexport function defaultGenerateSourceMap(ms: MagicStringLike, fileName: string) {\n\treturn ms.generateMap({\n\t\tfile: `${fileName}.map`,\n\t\tsource: fileName,\n\t\thires: true,\n\t});\n}\n\n/**\n * The default method to determine whether or not to minify a template. It will\n * return true for all tagged templates whose tag name contains \"html\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinify(template: Template) {\n\tconst tag = template.tag?.toLowerCase();\n\treturn !!tag && (tag.includes(\"html\") || tag.includes(\"svg\"));\n}\n\n/**\n * The default method to determine whether or not to minify a CSS template. It\n * will return true for all tagged templates whose tag name contains \"css\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinifyCSS(template: Template) {\n\tif (!template?.tag?.toLowerCase().includes(\"css\")) return false;\n\treturn true;\n}\n\n/**\n * The default validation.\n */\nexport const defaultValidation: Validation = {\n\tensurePlaceholderValid(placeholder) {\n\t\tif (typeof placeholder !== \"string\" || !placeholder.length) {\n\t\t\tthrow new Error(\"getPlaceholder() must return a non-empty string\");\n\t\t}\n\t},\n\tensureHTMLPartsValid(parts, htmlParts) {\n\t\tif (parts.length !== htmlParts.length) {\n\t\t\tthrow new Error(\"splitHTMLByPlaceholder() must return same number of strings as template parts\");\n\t\t}\n\t},\n};\n\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals(source: string, options?: DefaultOptions): Promise<Result | null>;\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals<S extends Strategy>(\n\tsource: string,\n\toptions?: CustomOptions<S>,\n): Promise<Result | null>;\n\nexport async function minifyHTMLLiterals(source: string, options: Options = {}): Promise<Result | null> {\n\toptions.MagicString = (options.MagicString || MagicString) as typeof options.MagicString;\n\toptions.parseLiterals = options.parseLiterals || parseLiterals;\n\toptions.shouldMinify = options.shouldMinify || defaultShouldMinify;\n\toptions.shouldMinifyCSS = options.shouldMinifyCSS || defaultShouldMinifyCSS;\n\n\toptions.minifyOptions = {\n\t\t...defaultMinifyOptions,\n\t\t...options.minifyOptions,\n\t};\n\n\toptions.parseLiteralsOptions = {\n\t\tfileName: options.fileName,\n\t\t...options.parseLiteralsOptions,\n\t};\n\n\tconst templates = options.parseLiterals(source, options.parseLiteralsOptions);\n\tconst strategy = <Strategy>(<CustomOptions<any>>options).strategy || defaultStrategy;\n\tconst { shouldMinify, shouldMinifyCSS } = options;\n\tlet validate: Validation | undefined;\n\tif (options.validate !== false) {\n\t\tvalidate = options.validate || defaultValidation;\n\t}\n\n\tlet skipCSS = false;\n\tlet skipHTML = false;\n\n\tif (strategy.minifyCSS && source.includes(\"unsafeCSS\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeCSS() detected in source. CSS minification will not be performed for this file.`,\n\t\t);\n\t\tskipCSS = true;\n\t}\n\n\tif (source.includes(\"unsafeHTML\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeHTML() detected in source. HTML minification will not be performed for this file.`,\n\t\t);\n\t\tskipHTML = true;\n\t}\n\n\tif (!options.MagicString) throw new Error(\"MagicString is required, this should never happen\");\n\tconst ms = new options.MagicString(source);\n\n\tconst promises = templates.map(async (template) => {\n\t\tconst minifyHTML = !skipHTML && shouldMinify(template);\n\t\tconst minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);\n\n\t\tif (!(minifyHTML || minifyCSS)) return;\n\n\t\tconst placeholder = strategy.getPlaceholder(template.parts);\n\t\tif (validate) {\n\t\t\tvalidate.ensurePlaceholderValid(placeholder);\n\t\t}\n\n\t\tconst combined = strategy.combineHTMLStrings(template.parts, placeholder);\n\t\tlet min: string;\n\n\t\tif (minifyCSS) {\n\t\t\tconst minifyCSSOptions = (options as DefaultOptions).minifyOptions?.minifyCSS;\n\t\t\tif (typeof minifyCSSOptions === \"function\") {\n\t\t\t\tmin = minifyCSSOptions(combined);\n\t\t\t} else if (minifyCSSOptions === false) {\n\t\t\t\tmin = combined;\n\t\t\t} else {\n\t\t\t\tconst cssOptions = typeof minifyCSSOptions === \"object\" ? minifyCSSOptions : undefined;\n\t\t\t\tmin = (await strategy.minifyCSS?.(combined, cssOptions)) ?? combined;\n\t\t\t}\n\t\t} else {\n\t\t\tmin = await strategy.minifyHTML(combined, options.minifyOptions);\n\t\t}\n\n\t\tconst minParts = strategy.splitHTMLByPlaceholder(min, placeholder);\n\t\tif (validate) validate.ensureHTMLPartsValid(template.parts, minParts);\n\n\t\tfor (const [index, part] of template.parts.entries()) {\n\t\t\tif (part.start < part.end)\n\t\t\t\t// Only overwrite if the literal part has text content\n\t\t\t\tms.overwrite(part.start, part.end, minParts[index] ?? \"\");\n\t\t}\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst sourceMin = ms.toString();\n\n\tif (source === sourceMin) return null;\n\n\tlet map: SourceMap | undefined;\n\tif (options.generateSourceMap !== false) {\n\t\tconst generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;\n\t\tmap = generateSourceMap(ms, options.fileName || \"\");\n\t}\n\n\treturn {\n\t\tmap,\n\t\tcode: sourceMin,\n\t};\n}\n","import CleanCSS from \"clean-css\";\nimport { type Options as HTMLOptions, minify } from \"html-minifier-terser\";\nimport type { TemplatePart } from \"parse-literals\";\n\n/**\n * A strategy on how to minify HTML and optionally CSS.\n *\n * @template O minify HTML options\n * @template C minify CSS options\n */\nexport interface Strategy<O = any, C = any> {\n\t/**\n\t * Retrieve a placeholder for the given array of template parts. The\n\t * placeholder returned should be the same if the function is invoked with the\n\t * same array of parts.\n\t *\n\t * The placeholder should be an HTML-compliant string that is not present in\n\t * any of the parts' text.\n\t *\n\t * @param parts the parts to get a placeholder for\n\t * @returns the placeholder\n\t */\n\tgetPlaceholder(parts: TemplatePart[]): string;\n\t/**\n\t * Combines the parts' HTML text strings together into a single string using\n\t * the provided placeholder. The placeholder indicates where a template\n\t * expression occurs.\n\t *\n\t * @param parts the parts to combine\n\t * @param placeholder the placeholder to use between parts\n\t * @returns the combined parts' text strings\n\t */\n\tcombineHTMLStrings(parts: TemplatePart[], placeholder: string): string;\n\t/**\n\t * Minfies the provided HTML string.\n\t *\n\t * @param html the html to minify\n\t * @param options html minify options\n\t * @returns minified HTML string\n\t */\n\tminifyHTML(html: string, options?: O): Promise<string>;\n\t/**\n\t * Minifies the provided CSS string.\n\t *\n\t * @param css the css to minfiy\n\t * @param options css minify options\n\t * @returns minified CSS string\n\t */\n\tminifyCSS?(css: string, options?: C): Promise<string>;\n\t/**\n\t * Splits a minfied HTML string back into an array of strings from the\n\t * provided placeholder. The returned array of strings should be the same\n\t * length as the template parts that were combined to make the HTML string.\n\t *\n\t * @param html the html string to split\n\t * @param placeholder the placeholder to split by\n\t * @returns an array of html strings\n\t */\n\tsplitHTMLByPlaceholder(html: string, placeholder: string): string[];\n}\n\n/**\n * The default <code>clean-css</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyCSSOptions: CleanCSS.Options = {};\n\n/**\n * The default <code>html-minifier</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyOptions: HTMLOptions = {\n\tcaseSensitive: true,\n\tcollapseWhitespace: true,\n\tdecodeEntities: true,\n\tminifyCSS: defaultMinifyCSSOptions,\n\tminifyJS: true,\n\tprocessConditionalComments: true,\n\tremoveAttributeQuotes: false,\n\tremoveComments: true,\n\tremoveEmptyAttributes: true,\n\tremoveScriptTypeAttributes: true,\n\tremoveStyleLinkTypeAttributes: true,\n\tuseShortDoctype: true,\n};\n\n/**\n * The default strategy. This uses <code>html-minifier</code> to minify HTML and\n * <code>clean-css</code> to minify CSS.\n */\nexport const defaultStrategy: Strategy<HTMLOptions, CleanCSS.Options> = {\n\tgetPlaceholder(parts) {\n\t\t// Using @ and (); will cause the expression not to be removed in CSS.\n\t\t// However, sometimes the semicolon can be removed (ex: inline styles).\n\t\t// In those cases, we want to make sure that the HTML splitting also\n\t\t// accounts for the missing semicolon.\n\t\tconst suffix = \"();\";\n\t\tlet placeholder = \"@TEMPLATE_EXPRESSION\";\n\t\twhile (parts.some((part) => part.text.includes(placeholder + suffix))) {\n\t\t\tplaceholder += \"_\";\n\t\t}\n\n\t\treturn placeholder + suffix;\n\t},\n\n\tcombineHTMLStrings(parts, placeholder) {\n\t\treturn parts.map((part) => part.text).join(placeholder);\n\t},\n\n\tasync minifyHTML(html, options = {}) {\n\t\tlet minifyCSSOptions: HTMLOptions[\"minifyCSS\"];\n\n\t\tif (html.match(/<!--(.*?)@TEMPLATE_EXPRESSION\\(\\);(.*?)-->/g)) {\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: HTML minification is not supported for template expressions inside comments. Minification for this file will be skipped.\",\n\t\t\t);\n\t\t\treturn html;\n\t\t}\n\n\t\thtml = html.replaceAll(\"<@TEMPLATE_EXPRESSION();\", \"<TEMPLATE_EXPRESSION___\");\n\t\thtml = html.replaceAll(\"</@TEMPLATE_EXPRESSION();\", \"</TEMPLATE_EXPRESSION___\");\n\n\t\tif (options.minifyCSS) {\n\t\t\tif (options.minifyCSS !== true && typeof options.minifyCSS !== \"function\") {\n\t\t\t\tminifyCSSOptions = { ...options.minifyCSS };\n\t\t\t} else {\n\t\t\t\tminifyCSSOptions = {};\n\t\t\t}\n\t\t} else {\n\t\t\tminifyCSSOptions = false;\n\t\t}\n\n\t\tlet adjustedMinifyCSSOptions: false | ReturnType<typeof adjustMinifyCSSOptions> = false;\n\t\tif (minifyCSSOptions) {\n\t\t\tadjustedMinifyCSSOptions = adjustMinifyCSSOptions(minifyCSSOptions);\n\t\t}\n\n\t\tlet result = await minify(html, {\n\t\t\t...options,\n\t\t\tminifyCSS: adjustedMinifyCSSOptions,\n\t\t});\n\n\t\tresult = result.replaceAll(\"<TEMPLATE_EXPRESSION___\", \"<@TEMPLATE_EXPRESSION();\");\n\t\tresult = result.replaceAll(\"</TEMPLATE_EXPRESSION___\", \"</@TEMPLATE_EXPRESSION();\");\n\n\t\tif (options.collapseWhitespace) {\n\t\t\t// html-minifier does not support removing newlines inside <svg>\n\t\t\t// attributes. Support this, but be careful not to remove newlines from\n\t\t\t// supported areas (such as within <pre> and <textarea> tags).\n\t\t\tconst matches = Array.from(result.matchAll(/<svg/g)).reverse();\n\t\t\tfor (const match of matches) {\n\t\t\t\tconst startTagIndex = match.index ?? 0;\n\t\t\t\tconst closeTagIndex = result.indexOf(\"</svg\", startTagIndex);\n\t\t\t\tif (closeTagIndex < 0) {\n\t\t\t\t\t// Malformed SVG without a closing tag\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst start = result.substring(0, startTagIndex);\n\t\t\t\tlet svg = result.substring(startTagIndex, closeTagIndex);\n\t\t\t\tconst end = result.substring(closeTagIndex);\n\t\t\t\tsvg = svg.replace(/\\r?\\n/g, \"\");\n\t\t\t\tresult = start + svg + end;\n\t\t\t}\n\t\t}\n\t\tresult = fixCleanCssTidySelectors(html, result);\n\n\t\treturn result;\n\t},\n\tasync minifyCSS(css, options = {}) {\n\t\tconst adjustedOptions = adjustMinifyCSSOptions(options);\n\n\t\tcss = css.replaceAll(/@TEMPLATE_EXPRESSION\\(\\);:/g, \"--TEMPLATE-EXPRESSION:\");\n\t\tconst output = await new CleanCSS({\n\t\t\t...adjustedOptions,\n\t\t\treturnPromise: true,\n\t\t}).minify(css);\n\n\t\tif (output.errors?.length) throw new Error(output.errors.join(\"\\n\\n\"));\n\n\t\t// If there are warnings, return the unminified CSS.\n\t\t// CleanCSS can sometimes struggle with our preprocessed CSS due to the replaced template expressions.\n\t\tif (output.warnings?.length) console.log(css, output.styles);\n\t\tif (output.warnings.length) {\n\t\t\tconsole.warn(output.warnings.join(\"\\n\\n\"));\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: warnings during CSS minification, file was skipped. See above for details.\",\n\t\t\t);\n\t\t\treturn css.replace(/(\\n)|(\\r)/g, \"\");\n\t\t}\n\n\t\toutput.styles = output.styles.replaceAll(\"--TEMPLATE-EXPRESSION:\", \"@TEMPLATE_EXPRESSION();:\");\n\t\toutput.styles = fixCleanCssTidySelectors(css, output.styles);\n\t\treturn output.styles;\n\t},\n\tsplitHTMLByPlaceholder(html, placeholder) {\n\t\tconst parts = html.split(placeholder);\n\t\t// Make the last character (a semicolon) optional. See above.\n\t\tif (placeholder.endsWith(\";\")) {\n\t\t\tconst withoutSemicolon = placeholder.substring(0, placeholder.length - 1);\n\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\tparts.splice(i, 1, ...(parts[i]?.split(withoutSemicolon) ?? []));\n\t\t\t}\n\t\t}\n\n\t\treturn parts;\n\t},\n};\n\nexport function adjustMinifyCSSOptions(options: CleanCSS.Options = {}) {\n\tconst level = options.level;\n\n\tconst plugin = {\n\t\tlevel1: {\n\t\t\tvalue: (_name: any, value: string) => {\n\t\t\t\tif (!value.startsWith(\"@TEMPLATE_EXPRESSION\") || value.endsWith(\";\")) return value;\n\n\t\t\t\t// The CSS minifier has removed the semicolon from the placeholder\n\t\t\t\t// and we need to add it back.\n\t\t\t\treturn `${value};`;\n\t\t\t},\n\t\t},\n\t};\n\n\treturn {\n\t\t...options,\n\t\tlevel,\n\t\tplugins: [plugin],\n\t};\n}\n\n// Should be fixed in clean-css https://github.com/clean-css/clean-css/issues/996, but is still happening\nfunction fixCleanCssTidySelectors(original: string, result: string) {\n\tconst regex = /(::?.+\\((.*)\\))[\\s\\r\\n]*{/gm;\n\tlet match: RegExpMatchArray | null;\n\t// biome-ignore lint/suspicious/noAssignInExpressions: this is fine\n\twhile ((match = regex.exec(original)) != null) {\n\t\tconst pseudoClass = match[1] ?? \"\";\n\t\tconst parameters = match[2];\n\n\t\tif (!parameters?.match(/\\s/)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parametersWithoutSpaces = parameters.replace(/\\s/g, \"\");\n\t\tconst resultPseudoClass = pseudoClass.replace(parameters, parametersWithoutSpaces);\n\t\tconst resultStartIndex = result.indexOf(resultPseudoClass);\n\t\tif (resultStartIndex < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst resultEndIndex = resultStartIndex + resultPseudoClass.length;\n\t\t// Restore the original pseudo class with spaces\n\t\tresult = result.substring(0, resultStartIndex) + pseudoClass + result.substring(resultEndIndex);\n\t}\n\n\treturn result;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAAmD;AACnD,4BAA2F;;;ACD3F,uBAAqB;AACrB,kCAAoD;AAgE7C,IAAM,0BAA4C,CAAC;AAMnD,IAAM,uBAAoC;AAAA,EAChD,eAAe;AAAA,EACf,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,WAAW;AAAA,EACX,UAAU;AAAA,EACV,4BAA4B;AAAA,EAC5B,uBAAuB;AAAA,EACvB,gBAAgB;AAAA,EAChB,uBAAuB;AAAA,EACvB,4BAA4B;AAAA,EAC5B,+BAA+B;AAAA,EAC/B,iBAAiB;AAClB;AAMO,IAAM,kBAA2D;AAAA,EACvE,eAAe,OAAO;AAKrB,UAAM,SAAS;AACf,QAAI,cAAc;AAClB,WAAO,MAAM,KAAK,CAAC,SAAS,KAAK,KAAK,SAAS,cAAc,MAAM,CAAC,GAAG;AACtE,qBAAe;AAAA,IAChB;AAEA,WAAO,cAAc;AAAA,EACtB;AAAA,EAEA,mBAAmB,OAAO,aAAa;AACtC,WAAO,MAAM,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE,KAAK,WAAW;AAAA,EACvD;AAAA,EAEA,MAAM,WAAW,MAAM,UAAU,CAAC,GAAG;AACpC,QAAI;AAEJ,QAAI,KAAK,MAAM,6CAA6C,GAAG;AAC9D,cAAQ;AAAA,QACP;AAAA,MACD;AACA,aAAO;AAAA,IACR;AAEA,WAAO,KAAK,WAAW,4BAA4B,yBAAyB;AAC5E,WAAO,KAAK,WAAW,6BAA6B,0BAA0B;AAE9E,QAAI,QAAQ,WAAW;AACtB,UAAI,QAAQ,cAAc,QAAQ,OAAO,QAAQ,cAAc,YAAY;AAC1E,2BAAmB,EAAE,GAAG,QAAQ,UAAU;AAAA,MAC3C,OAAO;AACN,2BAAmB,CAAC;AAAA,MACrB;AAAA,IACD,OAAO;AACN,yBAAmB;AAAA,IACpB;AAEA,QAAI,2BAA8E;AAClF,QAAI,kBAAkB;AACrB,iCAA2B,uBAAuB,gBAAgB;AAAA,IACnE;AAEA,QAAI,SAAS,UAAM,oCAAO,MAAM;AAAA,MAC/B,GAAG;AAAA,MACH,WAAW;AAAA,IACZ,CAAC;AAED,aAAS,OAAO,WAAW,2BAA2B,0BAA0B;AAChF,aAAS,OAAO,WAAW,4BAA4B,2BAA2B;AAElF,QAAI,QAAQ,oBAAoB;AAI/B,YAAM,UAAU,MAAM,KAAK,OAAO,SAAS,OAAO,CAAC,EAAE,QAAQ;AAC7D,iBAAW,SAAS,SAAS;AAC5B,cAAM,gBAAgB,MAAM,SAAS;AACrC,cAAM,gBAAgB,OAAO,QAAQ,SAAS,aAAa;AAC3D,YAAI,gBAAgB,GAAG;AAEtB;AAAA,QACD;AAEA,cAAM,QAAQ,OAAO,UAAU,GAAG,aAAa;AAC/C,YAAI,MAAM,OAAO,UAAU,eAAe,aAAa;AACvD,cAAM,MAAM,OAAO,UAAU,aAAa;AAC1C,cAAM,IAAI,QAAQ,UAAU,EAAE;AAC9B,iBAAS,QAAQ,MAAM;AAAA,MACxB;AAAA,IACD;AACA,aAAS,yBAAyB,MAAM,MAAM;AAE9C,WAAO;AAAA,EACR;AAAA,EACA,MAAM,UAAU,KAAK,UAAU,CAAC,GAAG;AAClC,UAAM,kBAAkB,uBAAuB,OAAO;AAEtD,UAAM,IAAI,WAAW,+BAA+B,wBAAwB;AAC5E,UAAM,SAAS,MAAM,IAAI,iBAAAA,QAAS;AAAA,MACjC,GAAG;AAAA,MACH,eAAe;AAAA,IAChB,CAAC,EAAE,OAAO,GAAG;AAEb,QAAI,OAAO,QAAQ;AAAQ,YAAM,IAAI,MAAM,OAAO,OAAO,KAAK,MAAM,CAAC;AAIrE,QAAI,OAAO,UAAU;AAAQ,cAAQ,IAAI,KAAK,OAAO,MAAM;AAC3D,QAAI,OAAO,SAAS,QAAQ;AAC3B,cAAQ,KAAK,OAAO,SAAS,KAAK,MAAM,CAAC;AACzC,cAAQ;AAAA,QACP;AAAA,MACD;AACA,aAAO,IAAI,QAAQ,cAAc,EAAE;AAAA,IACpC;AAEA,WAAO,SAAS,OAAO,OAAO,WAAW,0BAA0B,0BAA0B;AAC7F,WAAO,SAAS,yBAAyB,KAAK,OAAO,MAAM;AAC3D,WAAO,OAAO;AAAA,EACf;AAAA,EACA,uBAAuB,MAAM,aAAa;AACzC,UAAM,QAAQ,KAAK,MAAM,WAAW;AAEpC,QAAI,YAAY,SAAS,GAAG,GAAG;AAC9B,YAAM,mBAAmB,YAAY,UAAU,GAAG,YAAY,SAAS,CAAC;AACxE,eAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AAC3C,cAAM,OAAO,GAAG,GAAG,GAAI,MAAM,CAAC,GAAG,MAAM,gBAAgB,KAAK,CAAC,CAAE;AAAA,MAChE;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AACD;AAEO,SAAS,uBAAuB,UAA4B,CAAC,GAAG;AACtE,QAAM,QAAQ,QAAQ;AAEtB,QAAM,SAAS;AAAA,IACd,QAAQ;AAAA,MACP,OAAO,CAAC,OAAY,UAAkB;AACrC,YAAI,CAAC,MAAM,WAAW,sBAAsB,KAAK,MAAM,SAAS,GAAG;AAAG,iBAAO;AAI7E,eAAO,GAAG,KAAK;AAAA,MAChB;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AAAA,IACN,GAAG;AAAA,IACH;AAAA,IACA,SAAS,CAAC,MAAM;AAAA,EACjB;AACD;AAGA,SAAS,yBAAyB,UAAkB,QAAgB;AACnE,QAAM,QAAQ;AACd,MAAI;AAEJ,UAAQ,QAAQ,MAAM,KAAK,QAAQ,MAAM,MAAM;AAC9C,UAAM,cAAc,MAAM,CAAC,KAAK;AAChC,UAAM,aAAa,MAAM,CAAC;AAE1B,QAAI,CAAC,YAAY,MAAM,IAAI,GAAG;AAC7B;AAAA,IACD;AAEA,UAAM,0BAA0B,WAAW,QAAQ,OAAO,EAAE;AAC5D,UAAM,oBAAoB,YAAY,QAAQ,YAAY,uBAAuB;AACjF,UAAM,mBAAmB,OAAO,QAAQ,iBAAiB;AACzD,QAAI,mBAAmB,GAAG;AACzB;AAAA,IACD;AAEA,UAAM,iBAAiB,mBAAmB,kBAAkB;AAE5D,aAAS,OAAO,UAAU,GAAG,gBAAgB,IAAI,cAAc,OAAO,UAAU,cAAc;AAAA,EAC/F;AAEA,SAAO;AACR;;;ADpFO,SAAS,yBAAyB,IAAqB,UAAkB;AAC/E,SAAO,GAAG,YAAY;AAAA,IACrB,MAAM,GAAG,QAAQ;AAAA,IACjB,QAAQ;AAAA,IACR,OAAO;AAAA,EACR,CAAC;AACF;AAUO,SAAS,oBAAoB,UAAoB;AACvD,QAAM,MAAM,SAAS,KAAK,YAAY;AACtC,SAAO,CAAC,CAAC,QAAQ,IAAI,SAAS,MAAM,KAAK,IAAI,SAAS,KAAK;AAC5D;AAUO,SAAS,uBAAuB,UAAoB;AAC1D,MAAI,CAAC,UAAU,KAAK,YAAY,EAAE,SAAS,KAAK;AAAG,WAAO;AAC1D,SAAO;AACR;AAKO,IAAM,oBAAgC;AAAA,EAC5C,uBAAuB,aAAa;AACnC,QAAI,OAAO,gBAAgB,YAAY,CAAC,YAAY,QAAQ;AAC3D,YAAM,IAAI,MAAM,iDAAiD;AAAA,IAClE;AAAA,EACD;AAAA,EACA,qBAAqB,OAAO,WAAW;AACtC,QAAI,MAAM,WAAW,UAAU,QAAQ;AACtC,YAAM,IAAI,MAAM,+EAA+E;AAAA,IAChG;AAAA,EACD;AACD;AAsBA,eAAsB,mBAAmB,QAAgB,UAAmB,CAAC,GAA2B;AACvG,UAAQ,cAAe,QAAQ,eAAe,oBAAAC;AAC9C,UAAQ,gBAAgB,QAAQ,iBAAiB;AACjD,UAAQ,eAAe,QAAQ,gBAAgB;AAC/C,UAAQ,kBAAkB,QAAQ,mBAAmB;AAErD,UAAQ,gBAAgB;AAAA,IACvB,GAAG;AAAA,IACH,GAAG,QAAQ;AAAA,EACZ;AAEA,UAAQ,uBAAuB;AAAA,IAC9B,UAAU,QAAQ;AAAA,IAClB,GAAG,QAAQ;AAAA,EACZ;AAEA,QAAM,YAAY,QAAQ,cAAc,QAAQ,QAAQ,oBAAoB;AAC5E,QAAM,WAA0C,QAAS,YAAY;AACrE,QAAM,EAAE,cAAc,gBAAgB,IAAI;AAC1C,MAAI;AACJ,MAAI,QAAQ,aAAa,OAAO;AAC/B,eAAW,QAAQ,YAAY;AAAA,EAChC;AAEA,MAAI,UAAU;AACd,MAAI,WAAW;AAEf,MAAI,SAAS,aAAa,OAAO,SAAS,WAAW,GAAG;AACvD,YAAQ;AAAA,MACP;AAAA,IACD;AACA,cAAU;AAAA,EACX;AAEA,MAAI,OAAO,SAAS,YAAY,GAAG;AAClC,YAAQ;AAAA,MACP;AAAA,IACD;AACA,eAAW;AAAA,EACZ;AAEA,MAAI,CAAC,QAAQ;AAAa,UAAM,IAAI,MAAM,mDAAmD;AAC7F,QAAM,KAAK,IAAI,QAAQ,YAAY,MAAM;AAEzC,QAAM,WAAW,UAAU,IAAI,OAAO,aAAa;AAClD,UAAM,aAAa,CAAC,YAAY,aAAa,QAAQ;AACrD,UAAM,YAAY,CAAC,WAAW,SAAS,aAAa,gBAAgB,QAAQ;AAE5E,QAAI,EAAE,cAAc;AAAY;AAEhC,UAAM,cAAc,SAAS,eAAe,SAAS,KAAK;AAC1D,QAAI,UAAU;AACb,eAAS,uBAAuB,WAAW;AAAA,IAC5C;AAEA,UAAM,WAAW,SAAS,mBAAmB,SAAS,OAAO,WAAW;AACxE,QAAI;AAEJ,QAAI,WAAW;AACd,YAAM,mBAAoB,QAA2B,eAAe;AACpE,UAAI,OAAO,qBAAqB,YAAY;AAC3C,cAAM,iBAAiB,QAAQ;AAAA,MAChC,WAAW,qBAAqB,OAAO;AACtC,cAAM;AAAA,MACP,OAAO;AACN,cAAM,aAAa,OAAO,qBAAqB,WAAW,mBAAmB;AAC7E,cAAO,MAAM,SAAS,YAAY,UAAU,UAAU,KAAM;AAAA,MAC7D;AAAA,IACD,OAAO;AACN,YAAM,MAAM,SAAS,WAAW,UAAU,QAAQ,aAAa;AAAA,IAChE;AAEA,UAAM,WAAW,SAAS,uBAAuB,KAAK,WAAW;AACjE,QAAI;AAAU,eAAS,qBAAqB,SAAS,OAAO,QAAQ;AAEpE,eAAW,CAAC,OAAO,IAAI,KAAK,SAAS,MAAM,QAAQ,GAAG;AACrD,UAAI,KAAK,QAAQ,KAAK;AAErB,WAAG,UAAU,KAAK,OAAO,KAAK,KAAK,SAAS,KAAK,KAAK,EAAE;AAAA,IAC1D;AAAA,EACD,CAAC;AAED,QAAM,QAAQ,IAAI,QAAQ;AAE1B,QAAM,YAAY,GAAG,SAAS;AAE9B,MAAI,WAAW;AAAW,WAAO;AAEjC,MAAI;AACJ,MAAI,QAAQ,sBAAsB,OAAO;AACxC,UAAM,oBAAoB,QAAQ,qBAAqB;AACvD,UAAM,kBAAkB,IAAI,QAAQ,YAAY,EAAE;AAAA,EACnD;AAEA,SAAO;AAAA,IACN;AAAA,IACA,MAAM;AAAA,EACP;AACD;","names":["CleanCSS","MagicString"]}
\ No newline at end of file
+{"version":3,"sources":["../lib/index.ts","../lib/strategy.ts"],"sourcesContent":["import MagicString, { type SourceMapOptions } from \"magic-string\";\nimport { type Template, type TemplatePart, type ParseLiteralsOptions, parseLiterals } from \"parse-literals\";\nimport { type Strategy, defaultMinifyOptions, defaultStrategy } from \"./strategy.js\";\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport type Options = DefaultOptions | CustomOptions<any>;\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using default html-minifier\n * strategy.\n */\nexport interface DefaultOptions extends BaseOptions {\n\t/**\n\t * <code>html-minifier</code> options to use. Defaults to\n\t * <code>defaultMinifyOptions</code>, for production-ready minification.\n\t */\n\tminifyOptions?: Partial<typeof defaultMinifyOptions>;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using a custom strategy.\n */\nexport interface CustomOptions<S extends Strategy> extends BaseOptions {\n\t/**\n\t * HTML minification options.\n\t */\n\tminifyOptions?: S extends Strategy<infer O> ? Partial<O> : never;\n\t/**\n\t * Override the default strategy for how to minify HTML. The default is to\n\t * use <code>html-minifier</code>.\n\t */\n\tstrategy: S;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport interface BaseOptions {\n\t/**\n\t * The name of the file. This is used to determine how to parse the source\n\t * code and for source map filenames. It may be a base name, relative, or\n\t * absolute path.\n\t */\n\tfileName?: string;\n\t/**\n\t * Override how source maps are generated. Set to false to disable source map\n\t * generation.\n\t *\n\t * @param ms the MagicString instance with code modifications\n\t * @param fileName the name or path of the file\n\t * @returns a v3 SourceMap or undefined\n\t */\n\tgenerateSourceMap?: ((ms: MagicStringLike, fileName: string) => SourceMap | undefined) | false;\n\t/**\n\t * The MagicString-like constructor to use. MagicString is used to replace\n\t * strings and generate source maps.\n\t *\n\t * Override if you want to set your own version of MagicString or change how\n\t * strings are overridden. Use <code>generateSourceMap</code> if you want to\n\t * change how source maps are created.\n\t */\n\tMagicString?: { new (source: string): MagicStringLike };\n\t/**\n\t * Override how template literals are parsed from a source string.\n\t */\n\tparseLiterals?: typeof parseLiterals;\n\t/**\n\t * Options for <code>parseLiterals()</code>.\n\t */\n\tparseLiteralsOptions?: Partial<ParseLiteralsOptions>;\n\t/**\n\t * Determines whether or not a template should be minified. The default is to\n\t * minify all tagged template whose tag name contains \"html\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinify?(template: Template): boolean;\n\t/**\n\t * Determines whether or not a CSS template should be minified. The default is\n\t * to minify all tagged template whose tag name contains \"css\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinifyCSS?(template: Template): boolean;\n\t/**\n\t * Override custom validation or set to false to disable validation. This is\n\t * only useful when implementing your own strategy that may return\n\t * unexpected results.\n\t */\n\tvalidate?: Validation | false;\n}\n\n/**\n * A MagicString-like instance. <code>minify-literals</code> only uses a\n * subset of the MagicString API to overwrite the source code and generate\n * source maps.\n */\nexport interface MagicStringLike {\n\tgenerateMap(options?: Partial<SourceMapOptions>): SourceMap;\n\toverwrite(start: number, end: number, content: string): any;\n\ttoString(): string;\n}\n\n/**\n * A v3 SourceMap.\n *\n * <code>magic-string> incorrectly declares the SourceMap type with a version\n * string instead of a number, so <code>minify-literals</code> declares\n * its own type.\n */\nexport interface SourceMap {\n\tversion: number | string;\n\tfile: string | null;\n\tsources: Array<string | null>;\n\tsourcesContent: Array<string | null>;\n\tnames: string[];\n\tmappings: string;\n\ttoString(): string;\n\ttoUrl(): string;\n}\n\n/**\n * Validation that is executed when minifying HTML to ensure there are no\n * unexpected errors. This is to alleviate hard-to-troubleshoot errors such as\n * undefined errors.\n */\nexport interface Validation {\n\t/**\n\t * Throws an error if <code>strategy.getPlaceholder()</code> does not return\n\t * a valid placeholder string.\n\t *\n\t * @param placeholder the placeholder to check\n\t */\n\tensurePlaceholderValid(placeholder: any): void;\n\t/**\n\t * Throws an error if <code>strategy.splitHTMLByPlaceholder()</code> does not\n\t * return an HTML part string for each template part.\n\t *\n\t * @param parts the template parts that generated the strings\n\t * @param htmlParts the split HTML strings\n\t */\n\tensureHTMLPartsValid(parts: TemplatePart[], htmlParts: string[]): void;\n}\n\n/**\n * The result of a call to <code>minifyHTMLLiterals()</code>.\n */\nexport interface Result {\n\t/**\n\t * The minified code.\n\t */\n\tcode: string;\n\t/**\n\t * Optional v3 SourceMap for the code.\n\t */\n\tmap?: SourceMap | undefined;\n}\n\n/**\n * The default method to generate a SourceMap. It will generate the SourceMap\n * from the provided MagicString instance using \"fileName.map\" as the file and\n * \"fileName\" as the source.\n *\n * @param ms the MagicString instance with code modifications\n * @param fileName the name of the source file\n * @returns a v3 SourceMap\n */\nexport function defaultGenerateSourceMap(ms: MagicStringLike, fileName: string) {\n\treturn ms.generateMap({\n\t\tfile: `${fileName}.map`,\n\t\tsource: fileName,\n\t\thires: true,\n\t});\n}\n\n/**\n * The default method to determine whether or not to minify a template. It will\n * return true for all tagged templates whose tag name contains \"html\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinify(template: Template) {\n\tconst tag = template.tag?.toLowerCase();\n\treturn !!tag && (tag.includes(\"html\") || tag.includes(\"svg\"));\n}\n\n/**\n * The default method to determine whether or not to minify a CSS template. It\n * will return true for all tagged templates whose tag name contains \"css\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinifyCSS(template: Template) {\n\tif (!template?.tag?.toLowerCase().includes(\"css\")) return false;\n\treturn true;\n}\n\n/**\n * The default validation.\n */\nexport const defaultValidation: Validation = {\n\tensurePlaceholderValid(placeholder) {\n\t\tif (typeof placeholder === \"string\" && placeholder.length > 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (Array.isArray(placeholder) && placeholder.every((ph) => ph.length > 0)) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(\"getPlaceholder() must return a non-empty string | string[]\");\n\t},\n\tensureHTMLPartsValid(parts, htmlParts) {\n\t\tif (parts.length !== htmlParts.length) {\n\t\t\tthrow new Error(\"splitHTMLByPlaceholder() must return same number of strings as template parts\");\n\t\t}\n\t},\n};\n\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals(source: string, options?: DefaultOptions): Promise<Result | null>;\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals<S extends Strategy>(\n\tsource: string,\n\toptions?: CustomOptions<S>,\n): Promise<Result | null>;\n\nexport async function minifyHTMLLiterals(source: string, options: Options = {}): Promise<Result | null> {\n\toptions.MagicString = (options.MagicString || MagicString) as typeof options.MagicString;\n\toptions.parseLiterals = options.parseLiterals || parseLiterals;\n\toptions.shouldMinify = options.shouldMinify || defaultShouldMinify;\n\toptions.shouldMinifyCSS = options.shouldMinifyCSS || defaultShouldMinifyCSS;\n\n\toptions.minifyOptions = {\n\t\t...defaultMinifyOptions,\n\t\t...options.minifyOptions,\n\t};\n\n\toptions.parseLiteralsOptions = {\n\t\tfileName: options.fileName,\n\t\t...options.parseLiteralsOptions,\n\t};\n\n\tconst templates = options.parseLiterals(source, options.parseLiteralsOptions);\n\tconst strategy = <Strategy>(<CustomOptions<any>>options).strategy || defaultStrategy;\n\tconst { shouldMinify, shouldMinifyCSS } = options;\n\tlet validate: Validation | undefined;\n\tif (options.validate !== false) {\n\t\tvalidate = options.validate || defaultValidation;\n\t}\n\n\tlet skipCSS = false;\n\tlet skipHTML = false;\n\n\tif (strategy.minifyCSS && source.includes(\"unsafeCSS\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeCSS() detected in source. CSS minification will not be performed for this file.`,\n\t\t);\n\t\tskipCSS = true;\n\t}\n\n\tif (source.includes(\"unsafeHTML\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeHTML() detected in source. HTML minification will not be performed for this file.`,\n\t\t);\n\t\tskipHTML = true;\n\t}\n\n\tif (!options.MagicString) throw new Error(\"MagicString is required, this should never happen\");\n\tconst ms = new options.MagicString(source);\n\n\tconst promises = templates.map(async (template) => {\n\t\tconst minifyHTML = !skipHTML && shouldMinify(template);\n\t\tconst minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);\n\n\t\tif (!(minifyHTML || minifyCSS)) return;\n\n\t\tconst placeholder = strategy.getPlaceholder(template.parts, template.tag);\n\t\tif (validate) {\n\t\t\tvalidate.ensurePlaceholderValid(placeholder);\n\t\t}\n\n\t\tconst combined = strategy.combineHTMLStrings(template.parts, placeholder);\n\t\tlet min: string;\n\n\t\tif (minifyCSS) {\n\t\t\tconst minifyCSSOptions = (options as DefaultOptions).minifyOptions?.minifyCSS;\n\t\t\tif (typeof minifyCSSOptions === \"function\") {\n\t\t\t\tmin = minifyCSSOptions(combined);\n\t\t\t} else if (minifyCSSOptions === false) {\n\t\t\t\tmin = combined;\n\t\t\t} else {\n\t\t\t\tconst cssOptions = typeof minifyCSSOptions === \"object\" ? minifyCSSOptions : undefined;\n\t\t\t\tmin = (await strategy.minifyCSS?.(combined, cssOptions)) ?? combined;\n\t\t\t}\n\t\t} else {\n\t\t\tmin = await strategy.minifyHTML(combined, options.minifyOptions);\n\t\t}\n\n\t\tconst minParts = strategy.splitHTMLByPlaceholder(min, placeholder);\n\t\tif (validate) validate.ensureHTMLPartsValid(template.parts, minParts);\n\n\t\tfor (const [index, part] of template.parts.entries()) {\n\t\t\tif (part.start < part.end)\n\t\t\t\t// Only overwrite if the literal part has text content\n\t\t\t\tms.overwrite(part.start, part.end, minParts[index] ?? \"\");\n\t\t}\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst sourceMin = ms.toString();\n\n\tif (source === sourceMin) return null;\n\n\tlet map: SourceMap | undefined;\n\tif (options.generateSourceMap !== false) {\n\t\tconst generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;\n\t\tmap = generateSourceMap(ms, options.fileName || \"\");\n\t}\n\n\treturn {\n\t\tmap,\n\t\tcode: sourceMin,\n\t};\n}\n","import CleanCSS from \"clean-css\";\nimport { type Options as HTMLOptions, minify } from \"html-minifier-terser\";\nimport type { TemplatePart } from \"parse-literals\";\nimport { randomBytes, randomInt } from \"node:crypto\";\n\n/**\n * A strategy on how to minify HTML and optionally CSS.\n *\n * @template O minify HTML options\n * @template C minify CSS options\n */\nexport interface Strategy<O = any, C = any> {\n\t/**\n\t * Retrieve a placeholder for the given array of template parts. The\n\t * placeholder returned should be the same if the function is invoked with the\n\t * same array of parts.\n\t *\n\t * The placeholder should be an HTML-compliant string that is not present in\n\t * any of the parts' text.\n\t *\n\t * @param parts the parts to get a placeholder for\n\t * @returns the placeholder\n\t */\n\tgetPlaceholder(parts: TemplatePart[], tag?: string): string | string[];\n\t/**\n\t * Combines the parts' HTML text strings together into a single string using\n\t * the provided placeholder. The placeholder indicates where a template\n\t * expression occurs.\n\t *\n\t * @param parts the parts to combine\n\t * @param placeholder the placeholder to use between parts\n\t * @returns the combined parts' text strings\n\t */\n\tcombineHTMLStrings(parts: TemplatePart[], placeholder: string | string[]): string;\n\t/**\n\t * Minfies the provided HTML string.\n\t *\n\t * @param html the html to minify\n\t * @param options html minify options\n\t * @returns minified HTML string\n\t */\n\tminifyHTML(html: string, options?: O): Promise<string>;\n\t/**\n\t * Minifies the provided CSS string.\n\t *\n\t * @param css the css to minfiy\n\t * @param options css minify options\n\t * @returns minified CSS string\n\t */\n\tminifyCSS?(css: string, options?: C): Promise<string>;\n\t/**\n\t * Splits a minfied HTML string back into an array of strings from the\n\t * provided placeholder. The returned array of strings should be the same\n\t * length as the template parts that were combined to make the HTML string.\n\t *\n\t * @param html the html string to split\n\t * @param placeholder the placeholder to split by\n\t * @returns an array of html strings\n\t */\n\tsplitHTMLByPlaceholder(html: string, placeholder: string | string[]): string[];\n}\n\n/**\n * The default <code>clean-css</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyCSSOptions: CleanCSS.Options = {};\n\n/**\n * The default <code>html-minifier</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyOptions: HTMLOptions = {\n\tcaseSensitive: true,\n\tcollapseWhitespace: true,\n\tdecodeEntities: true,\n\tminifyCSS: defaultMinifyCSSOptions,\n\tminifyJS: true,\n\tprocessConditionalComments: true,\n\tremoveAttributeQuotes: false,\n\tremoveComments: true,\n\tremoveEmptyAttributes: true,\n\tremoveScriptTypeAttributes: true,\n\tremoveStyleLinkTypeAttributes: true,\n\tuseShortDoctype: true,\n};\n\n/**\n * The default strategy. This uses <code>html-minifier</code> to minify HTML and\n * <code>clean-css</code> to minify CSS.\n */\nexport const defaultStrategy: Strategy<HTMLOptions, CleanCSS.Options> = {\n\tgetPlaceholder(parts, tag) {\n\t\tconst isCss = tag?.toLowerCase().includes(\"css\");\n\t\tif (isCss) {\n\t\t\t// use strict mode to avoid issues with CSS minification\n\t\t\tconst random = `tmp_${randomBytes(6).toString(\"hex\")}`;\n\t\t\tconst placeholder: string[] = [];\n\t\t\tconst comment = /\\/\\*[\\s\\S]*?\\*\\//g;\n\t\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\t\tconst beforeFull = parts[i - 1]!.text;\n\t\t\t\tconst beforeCss = beforeFull.replace(comment, \"\");\n\t\t\t\tconst afterFull = parts[i]!.text;\n\t\t\t\tconst afterCss = afterFull.replace(comment, \"\");\n\t\t\t\t/**\n\t\t\t\t * 1. selector\n\t\t\t\t * ${selector} {\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 2. key\n\t\t\t\t * selector {\n\t\t\t\t * \t ${key}: value;\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 3. rule\n\t\t\t\t * [selector {}]\n\t\t\t\t * ${rule}\n\t\t\t\t * [selector {}]\n\t\t\t\t *\n\t\t\t\t * 4. number-literal\n\t\t\t\t * selector{\n\t\t\t\t *   key: ${param}px;\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 5. value\n\t\t\t\t * selector {\n\t\t\t\t * \t key: ${value};\n\t\t\t\t * \t key: ${value}\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 6. param\n\t\t\t\t * selector{\n\t\t\t\t *   key: fun(${param}[, ${param}]);\n\t\t\t\t * }\n\t\t\t\t */\n\n\t\t\t\tconst isSelector = /^\\s*\\{/.test(afterCss);\n\t\t\t\tif (isSelector) {\n\t\t\t\t\tplaceholder.push(`#${random}`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst isKey = /^\\s*:/.test(afterCss);\n\t\t\t\tif (isKey) {\n\t\t\t\t\tplaceholder.push(`--${random}`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst isRule = /\\}\\s*$/.test(beforeCss) || beforeCss.trim().length === 0;\n\t\t\t\tif (isRule) {\n\t\t\t\t\treturn `@${random}();`;\n\t\t\t\t}\n\t\t\t\tconst isUnit = /^\\w+/.test(afterCss);\n\t\t\t\tif (isUnit) {\n\t\t\t\t\tlet num: string;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tnum = `${randomInt(281474976710655)}`;\n\t\t\t\t\t\tif (!beforeFull.includes(num)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tplaceholder.push(num);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst isValue = /:\\s*$/.test(beforeCss);\n\t\t\t\tif (isValue) {\n\t\t\t\t\tplaceholder.push(`var(--${random})`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// isParams\n\t\t\t\tplaceholder.push(`var(--${random})`);\n\t\t\t}\n\t\t\treturn placeholder;\n\t\t}\n\t\t// Using @ and (); will cause the expression not to be removed in CSS.\n\t\t// However, sometimes the semicolon can be removed (ex: inline styles).\n\t\t// In those cases, we want to make sure that the HTML splitting also\n\t\t// accounts for the missing semicolon.\n\t\tconst suffix = \"();\";\n\t\tlet placeholder = \"@TEMPLATE_EXPRESSION\";\n\t\twhile (parts.some((part) => part.text.includes(placeholder + suffix))) {\n\t\t\tplaceholder += \"_\";\n\t\t}\n\n\t\treturn placeholder + suffix;\n\t},\n\n\tcombineHTMLStrings(parts, placeholder) {\n\t\tif (typeof placeholder === \"string\") {\n\t\t\treturn parts.map((part) => part.text).join(placeholder);\n\t\t}\n\t\treturn parts.map((part, i) => part.text + (placeholder[i] ?? \"\")).join(\"\");\n\t},\n\n\tasync minifyHTML(html, options = {}) {\n\t\tlet minifyCSSOptions: HTMLOptions[\"minifyCSS\"];\n\n\t\tif (html.match(/<!--(.*?)@TEMPLATE_EXPRESSION\\(\\);(.*?)-->/g)) {\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: HTML minification is not supported for template expressions inside comments. Minification for this file will be skipped.\",\n\t\t\t);\n\t\t\treturn html;\n\t\t}\n\n\t\thtml = html.replaceAll(\"<@TEMPLATE_EXPRESSION();\", \"<TEMPLATE_EXPRESSION___\");\n\t\thtml = html.replaceAll(\"</@TEMPLATE_EXPRESSION();\", \"</TEMPLATE_EXPRESSION___\");\n\n\t\tif (options.minifyCSS) {\n\t\t\tif (options.minifyCSS !== true && typeof options.minifyCSS !== \"function\") {\n\t\t\t\tminifyCSSOptions = { ...options.minifyCSS };\n\t\t\t} else {\n\t\t\t\tminifyCSSOptions = {};\n\t\t\t}\n\t\t} else {\n\t\t\tminifyCSSOptions = false;\n\t\t}\n\n\t\tlet adjustedMinifyCSSOptions: false | ReturnType<typeof adjustMinifyCSSOptions> = false;\n\t\tif (minifyCSSOptions) {\n\t\t\tadjustedMinifyCSSOptions = adjustMinifyCSSOptions(minifyCSSOptions);\n\t\t}\n\n\t\tlet result = await minify(html, {\n\t\t\t...options,\n\t\t\tminifyCSS: adjustedMinifyCSSOptions,\n\t\t});\n\n\t\tresult = result.replaceAll(\"<TEMPLATE_EXPRESSION___\", \"<@TEMPLATE_EXPRESSION();\");\n\t\tresult = result.replaceAll(\"</TEMPLATE_EXPRESSION___\", \"</@TEMPLATE_EXPRESSION();\");\n\n\t\tif (options.collapseWhitespace) {\n\t\t\t// html-minifier does not support removing newlines inside <svg>\n\t\t\t// attributes. Support this, but be careful not to remove newlines from\n\t\t\t// supported areas (such as within <pre> and <textarea> tags).\n\t\t\tconst matches = Array.from(result.matchAll(/<svg/g)).reverse();\n\t\t\tfor (const match of matches) {\n\t\t\t\tconst startTagIndex = match.index ?? 0;\n\t\t\t\tconst closeTagIndex = result.indexOf(\"</svg\", startTagIndex);\n\t\t\t\tif (closeTagIndex < 0) {\n\t\t\t\t\t// Malformed SVG without a closing tag\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst start = result.substring(0, startTagIndex);\n\t\t\t\tlet svg = result.substring(startTagIndex, closeTagIndex);\n\t\t\t\tconst end = result.substring(closeTagIndex);\n\t\t\t\tsvg = svg.replace(/\\r?\\n/g, \"\");\n\t\t\t\tresult = start + svg + end;\n\t\t\t}\n\t\t}\n\t\tresult = fixCleanCssTidySelectors(html, result);\n\n\t\treturn result;\n\t},\n\tasync minifyCSS(css, options = {}) {\n\t\tconst adjustedOptions = adjustMinifyCSSOptions(options);\n\n\t\tcss = css.replaceAll(/@TEMPLATE_EXPRESSION\\(\\);:/g, \"--TEMPLATE-EXPRESSION:\");\n\t\tconst output = await new CleanCSS({\n\t\t\t...adjustedOptions,\n\t\t\treturnPromise: true,\n\t\t}).minify(css);\n\n\t\tif (output.errors?.length) throw new Error(output.errors.join(\"\\n\\n\"));\n\n\t\t// If there are warnings, return the unminified CSS.\n\t\t// CleanCSS can sometimes struggle with our preprocessed CSS due to the replaced template expressions.\n\t\tif (output.warnings?.length) console.log(css, output.styles);\n\t\tif (output.warnings.length) {\n\t\t\tconsole.warn(output.warnings.join(\"\\n\\n\"));\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: warnings during CSS minification, file was skipped. See above for details.\",\n\t\t\t);\n\t\t\treturn css.replace(/(\\n)|(\\r)/g, \"\");\n\t\t}\n\n\t\toutput.styles = output.styles.replaceAll(\"--TEMPLATE-EXPRESSION:\", \"@TEMPLATE_EXPRESSION();:\");\n\t\toutput.styles = fixCleanCssTidySelectors(css, output.styles);\n\t\treturn output.styles;\n\t},\n\tsplitHTMLByPlaceholder(html, placeholder) {\n\t\tlet parts: string[];\n\t\tif (typeof placeholder === \"string\") {\n\t\t\tparts = html.split(placeholder);\n\t\t\t// Make the last character (a semicolon) optional. See above.\n\t\t\tif (placeholder.endsWith(\";\")) {\n\t\t\t\tconst withoutSemicolon = placeholder.substring(0, placeholder.length - 1);\n\t\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\t\tparts.splice(i, 1, ...(parts[i]?.split(withoutSemicolon) ?? []));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tparts = [];\n\t\t\t// strice mode\n\t\t\tlet pos = 0;\n\t\t\tlet index = -1;\n\t\t\tfor (const ph of placeholder) {\n\t\t\t\tindex = html.indexOf(ph, pos);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tthrow new Error(`placeholder ${ph} not found in html ${html}`);\n\t\t\t\t}\n\t\t\t\tparts.push(html.slice(pos, index));\n\t\t\t\tpos = index + ph.length;\n\t\t\t}\n\t\t\tparts.push(html.slice(pos));\n\t\t}\n\n\t\treturn parts;\n\t},\n};\n\nexport function adjustMinifyCSSOptions(options: CleanCSS.Options = {}) {\n\tconst level = options.level;\n\n\tconst plugin = {\n\t\tlevel1: {\n\t\t\tvalue: (_name: any, value: string) => {\n\t\t\t\tif (!value.startsWith(\"@TEMPLATE_EXPRESSION\") || value.endsWith(\";\")) return value;\n\n\t\t\t\t// The CSS minifier has removed the semicolon from the placeholder\n\t\t\t\t// and we need to add it back.\n\t\t\t\treturn `${value};`;\n\t\t\t},\n\t\t},\n\t};\n\n\treturn {\n\t\t...options,\n\t\tlevel,\n\t\tplugins: [plugin],\n\t};\n}\n\n// Should be fixed in clean-css https://github.com/clean-css/clean-css/issues/996, but is still happening\nfunction fixCleanCssTidySelectors(original: string, result: string) {\n\tconst regex = /(::?.+\\((.*)\\))[\\s\\r\\n]*{/gm;\n\tlet match: RegExpMatchArray | null;\n\t// biome-ignore lint/suspicious/noAssignInExpressions: this is fine\n\twhile ((match = regex.exec(original)) != null) {\n\t\tconst pseudoClass = match[1] ?? \"\";\n\t\tconst parameters = match[2];\n\n\t\tif (!parameters?.match(/\\s/)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parametersWithoutSpaces = parameters.replace(/\\s/g, \"\");\n\t\tconst resultPseudoClass = pseudoClass.replace(parameters, parametersWithoutSpaces);\n\t\tconst resultStartIndex = result.indexOf(resultPseudoClass);\n\t\tif (resultStartIndex < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst resultEndIndex = resultStartIndex + resultPseudoClass.length;\n\t\t// Restore the original pseudo class with spaces\n\t\tresult = result.substring(0, resultStartIndex) + pseudoClass + result.substring(resultEndIndex);\n\t}\n\n\treturn result;\n}\n"],"mappings":"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","names":["placeholder","CleanCSS","MagicString"]}
\ No newline at end of file
diff --git a/dist/index.d.cts b/dist/index.d.cts
index 520476a845831c6f5b284ff7f435cde9e292a5e8..29b91fbb5c9aa922402f7a524b86af27c09d232e 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -20,7 +20,7 @@ interface Strategy<O = any, C = any> {
      * @param parts the parts to get a placeholder for
      * @returns the placeholder
      */
-    getPlaceholder(parts: TemplatePart[]): string;
+    getPlaceholder(parts: TemplatePart[], tag?: string): string | string[];
     /**
      * Combines the parts' HTML text strings together into a single string using
      * the provided placeholder. The placeholder indicates where a template
@@ -30,7 +30,7 @@ interface Strategy<O = any, C = any> {
      * @param placeholder the placeholder to use between parts
      * @returns the combined parts' text strings
      */
-    combineHTMLStrings(parts: TemplatePart[], placeholder: string): string;
+    combineHTMLStrings(parts: TemplatePart[], placeholder: string | string[]): string;
     /**
      * Minfies the provided HTML string.
      *
@@ -56,7 +56,7 @@ interface Strategy<O = any, C = any> {
      * @param placeholder the placeholder to split by
      * @returns an array of html strings
      */
-    splitHTMLByPlaceholder(html: string, placeholder: string): string[];
+    splitHTMLByPlaceholder(html: string, placeholder: string | string[]): string[];
 }
 /**
  * The default <code>html-minifier</code> options, optimized for production
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 520476a845831c6f5b284ff7f435cde9e292a5e8..29b91fbb5c9aa922402f7a524b86af27c09d232e 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -20,7 +20,7 @@ interface Strategy<O = any, C = any> {
      * @param parts the parts to get a placeholder for
      * @returns the placeholder
      */
-    getPlaceholder(parts: TemplatePart[]): string;
+    getPlaceholder(parts: TemplatePart[], tag?: string): string | string[];
     /**
      * Combines the parts' HTML text strings together into a single string using
      * the provided placeholder. The placeholder indicates where a template
@@ -30,7 +30,7 @@ interface Strategy<O = any, C = any> {
      * @param placeholder the placeholder to use between parts
      * @returns the combined parts' text strings
      */
-    combineHTMLStrings(parts: TemplatePart[], placeholder: string): string;
+    combineHTMLStrings(parts: TemplatePart[], placeholder: string | string[]): string;
     /**
      * Minfies the provided HTML string.
      *
@@ -56,7 +56,7 @@ interface Strategy<O = any, C = any> {
      * @param placeholder the placeholder to split by
      * @returns an array of html strings
      */
-    splitHTMLByPlaceholder(html: string, placeholder: string): string[];
+    splitHTMLByPlaceholder(html: string, placeholder: string | string[]): string[];
 }
 /**
  * The default <code>html-minifier</code> options, optimized for production
diff --git a/dist/index.js b/dist/index.js
index 773e3a295a36015b1f0940d7fbbb2b3c601801d1..37761ffe0cb96edc18f6d0bc50580d388570962e 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -5,6 +5,7 @@ import { parseLiterals } from "parse-literals";
 // lib/strategy.ts
 import CleanCSS from "clean-css";
 import { minify } from "html-minifier-terser";
+import { randomBytes, randomInt } from "node:crypto";
 var defaultMinifyCSSOptions = {};
 var defaultMinifyOptions = {
   caseSensitive: true,
@@ -21,7 +22,52 @@ var defaultMinifyOptions = {
   useShortDoctype: true
 };
 var defaultStrategy = {
-  getPlaceholder(parts) {
+  getPlaceholder(parts, tag) {
+    const isCss = tag?.toLowerCase().includes("css");
+    if (isCss) {
+      const random = `tmp_${randomBytes(6).toString("hex")}`;
+      const placeholder2 = [];
+      const comment = /\/\*[\s\S]*?\*\//g;
+      for (let i = 1; i < parts.length; i++) {
+        const beforeFull = parts[i - 1].text;
+        const beforeCss = beforeFull.replace(comment, "");
+        const afterFull = parts[i].text;
+        const afterCss = afterFull.replace(comment, "");
+        const isSelector = /^\s*\{/.test(afterCss);
+        if (isSelector) {
+          placeholder2.push(`#${random}`);
+          continue;
+        }
+        const isKey = /^\s*:/.test(afterCss);
+        if (isKey) {
+          placeholder2.push(`--${random}`);
+          continue;
+        }
+        const isRule = /\}\s*$/.test(beforeCss) || beforeCss.trim().length === 0;
+        if (isRule) {
+          return `@${random}();`;
+        }
+        const isUnit = /^\w+/.test(afterCss);
+        if (isUnit) {
+          let num;
+          while (true) {
+            num = `${randomInt(281474976710655)}`;
+            if (!beforeFull.includes(num)) {
+              break;
+            }
+          }
+          placeholder2.push(num);
+          continue;
+        }
+        const isValue = /:\s*$/.test(beforeCss);
+        if (isValue) {
+          placeholder2.push(`var(--${random})`);
+          continue;
+        }
+        placeholder2.push(`var(--${random})`);
+      }
+      return placeholder2;
+    }
     const suffix = "();";
     let placeholder = "@TEMPLATE_EXPRESSION";
     while (parts.some((part) => part.text.includes(placeholder + suffix))) {
@@ -30,7 +76,10 @@ var defaultStrategy = {
     return placeholder + suffix;
   },
   combineHTMLStrings(parts, placeholder) {
-    return parts.map((part) => part.text).join(placeholder);
+    if (typeof placeholder === "string") {
+      return parts.map((part) => part.text).join(placeholder);
+    }
+    return parts.map((part, i) => part.text + (placeholder[i] ?? "")).join("");
   },
   async minifyHTML(html, options = {}) {
     let minifyCSSOptions;
@@ -86,10 +135,8 @@ var defaultStrategy = {
       ...adjustedOptions,
       returnPromise: true
     }).minify(css);
-    if (output.errors?.length)
-      throw new Error(output.errors.join("\n\n"));
-    if (output.warnings?.length)
-      console.log(css, output.styles);
+    if (output.errors?.length) throw new Error(output.errors.join("\n\n"));
+    if (output.warnings?.length) console.log(css, output.styles);
     if (output.warnings.length) {
       console.warn(output.warnings.join("\n\n"));
       console.warn(
@@ -102,12 +149,28 @@ var defaultStrategy = {
     return output.styles;
   },
   splitHTMLByPlaceholder(html, placeholder) {
-    const parts = html.split(placeholder);
-    if (placeholder.endsWith(";")) {
-      const withoutSemicolon = placeholder.substring(0, placeholder.length - 1);
-      for (let i = parts.length - 1; i >= 0; i--) {
-        parts.splice(i, 1, ...parts[i]?.split(withoutSemicolon) ?? []);
+    let parts;
+    if (typeof placeholder === "string") {
+      parts = html.split(placeholder);
+      if (placeholder.endsWith(";")) {
+        const withoutSemicolon = placeholder.substring(0, placeholder.length - 1);
+        for (let i = parts.length - 1; i >= 0; i--) {
+          parts.splice(i, 1, ...parts[i]?.split(withoutSemicolon) ?? []);
+        }
+      }
+    } else {
+      parts = [];
+      let pos = 0;
+      let index = -1;
+      for (const ph of placeholder) {
+        index = html.indexOf(ph, pos);
+        if (index === -1) {
+          throw new Error(`placeholder ${ph} not found in html ${html}`);
+        }
+        parts.push(html.slice(pos, index));
+        pos = index + ph.length;
       }
+      parts.push(html.slice(pos));
     }
     return parts;
   }
@@ -117,8 +180,7 @@ function adjustMinifyCSSOptions(options = {}) {
   const plugin = {
     level1: {
       value: (_name, value) => {
-        if (!value.startsWith("@TEMPLATE_EXPRESSION") || value.endsWith(";"))
-          return value;
+        if (!value.startsWith("@TEMPLATE_EXPRESSION") || value.endsWith(";")) return value;
         return `${value};`;
       }
     }
@@ -163,18 +225,21 @@ function defaultShouldMinify(template) {
   return !!tag && (tag.includes("html") || tag.includes("svg"));
 }
 function defaultShouldMinifyCSS(template) {
-  if (!template?.tag?.toLowerCase().includes("css"))
-    return false;
+  if (!template?.tag?.toLowerCase().includes("css")) return false;
   return true;
 }
 var defaultValidation = {
   ensurePlaceholderValid(placeholder) {
-    if (typeof placeholder !== "string" || !placeholder.length) {
-      throw new Error("getPlaceholder() must return a non-empty string");
+    if (typeof placeholder === "string" && placeholder.length > 0) {
+      return;
     }
+    if (Array.isArray(placeholder) && placeholder.every((ph) => ph.length > 0)) {
+      return;
+    }
+    throw new Error("getPlaceholder() must return a non-empty string | string[]");
   },
   ensureHTMLPartsValid(parts, htmlParts) {
-    if (parts.length !== htmlParts.length) {
+    if (parts.length !== htmlParts.length) {debugger;
       throw new Error("splitHTMLByPlaceholder() must return same number of strings as template parts");
     }
   }
@@ -213,15 +278,13 @@ async function minifyHTMLLiterals(source, options = {}) {
     );
     skipHTML = true;
   }
-  if (!options.MagicString)
-    throw new Error("MagicString is required, this should never happen");
+  if (!options.MagicString) throw new Error("MagicString is required, this should never happen");
   const ms = new options.MagicString(source);
   const promises = templates.map(async (template) => {
     const minifyHTML = !skipHTML && shouldMinify(template);
     const minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);
-    if (!(minifyHTML || minifyCSS))
-      return;
-    const placeholder = strategy.getPlaceholder(template.parts);
+    if (!(minifyHTML || minifyCSS)) return;
+    const placeholder = strategy.getPlaceholder(template.parts, template.tag);
     if (validate) {
       validate.ensurePlaceholderValid(placeholder);
     }
@@ -241,8 +304,7 @@ async function minifyHTMLLiterals(source, options = {}) {
       min = await strategy.minifyHTML(combined, options.minifyOptions);
     }
     const minParts = strategy.splitHTMLByPlaceholder(min, placeholder);
-    if (validate)
-      validate.ensureHTMLPartsValid(template.parts, minParts);
+    if (validate) validate.ensureHTMLPartsValid(template.parts, minParts);
     for (const [index, part] of template.parts.entries()) {
       if (part.start < part.end)
         ms.overwrite(part.start, part.end, minParts[index] ?? "");
@@ -250,8 +312,7 @@ async function minifyHTMLLiterals(source, options = {}) {
   });
   await Promise.all(promises);
   const sourceMin = ms.toString();
-  if (source === sourceMin)
-    return null;
+  if (source === sourceMin) return null;
   let map;
   if (options.generateSourceMap !== false) {
     const generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;
diff --git a/dist/index.js.map b/dist/index.js.map
index 66cd5c1d3c60a62a6f175e90d7c5fd4ef125f85a..18c7e8724a12f6186e39691bf1da9266902bc49f 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../lib/index.ts","../lib/strategy.ts"],"sourcesContent":["import MagicString, { type SourceMapOptions } from \"magic-string\";\nimport { type Template, type TemplatePart, type ParseLiteralsOptions, parseLiterals } from \"parse-literals\";\nimport { type Strategy, defaultMinifyOptions, defaultStrategy } from \"./strategy.js\";\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport type Options = DefaultOptions | CustomOptions<any>;\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using default html-minifier\n * strategy.\n */\nexport interface DefaultOptions extends BaseOptions {\n\t/**\n\t * <code>html-minifier</code> options to use. Defaults to\n\t * <code>defaultMinifyOptions</code>, for production-ready minification.\n\t */\n\tminifyOptions?: Partial<typeof defaultMinifyOptions>;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using a custom strategy.\n */\nexport interface CustomOptions<S extends Strategy> extends BaseOptions {\n\t/**\n\t * HTML minification options.\n\t */\n\tminifyOptions?: S extends Strategy<infer O> ? Partial<O> : never;\n\t/**\n\t * Override the default strategy for how to minify HTML. The default is to\n\t * use <code>html-minifier</code>.\n\t */\n\tstrategy: S;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport interface BaseOptions {\n\t/**\n\t * The name of the file. This is used to determine how to parse the source\n\t * code and for source map filenames. It may be a base name, relative, or\n\t * absolute path.\n\t */\n\tfileName?: string;\n\t/**\n\t * Override how source maps are generated. Set to false to disable source map\n\t * generation.\n\t *\n\t * @param ms the MagicString instance with code modifications\n\t * @param fileName the name or path of the file\n\t * @returns a v3 SourceMap or undefined\n\t */\n\tgenerateSourceMap?: ((ms: MagicStringLike, fileName: string) => SourceMap | undefined) | false;\n\t/**\n\t * The MagicString-like constructor to use. MagicString is used to replace\n\t * strings and generate source maps.\n\t *\n\t * Override if you want to set your own version of MagicString or change how\n\t * strings are overridden. Use <code>generateSourceMap</code> if you want to\n\t * change how source maps are created.\n\t */\n\tMagicString?: { new (source: string): MagicStringLike };\n\t/**\n\t * Override how template literals are parsed from a source string.\n\t */\n\tparseLiterals?: typeof parseLiterals;\n\t/**\n\t * Options for <code>parseLiterals()</code>.\n\t */\n\tparseLiteralsOptions?: Partial<ParseLiteralsOptions>;\n\t/**\n\t * Determines whether or not a template should be minified. The default is to\n\t * minify all tagged template whose tag name contains \"html\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinify?(template: Template): boolean;\n\t/**\n\t * Determines whether or not a CSS template should be minified. The default is\n\t * to minify all tagged template whose tag name contains \"css\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinifyCSS?(template: Template): boolean;\n\t/**\n\t * Override custom validation or set to false to disable validation. This is\n\t * only useful when implementing your own strategy that may return\n\t * unexpected results.\n\t */\n\tvalidate?: Validation | false;\n}\n\n/**\n * A MagicString-like instance. <code>minify-literals</code> only uses a\n * subset of the MagicString API to overwrite the source code and generate\n * source maps.\n */\nexport interface MagicStringLike {\n\tgenerateMap(options?: Partial<SourceMapOptions>): SourceMap;\n\toverwrite(start: number, end: number, content: string): any;\n\ttoString(): string;\n}\n\n/**\n * A v3 SourceMap.\n *\n * <code>magic-string> incorrectly declares the SourceMap type with a version\n * string instead of a number, so <code>minify-literals</code> declares\n * its own type.\n */\nexport interface SourceMap {\n\tversion: number | string;\n\tfile: string | null;\n\tsources: Array<string | null>;\n\tsourcesContent: Array<string | null>;\n\tnames: string[];\n\tmappings: string;\n\ttoString(): string;\n\ttoUrl(): string;\n}\n\n/**\n * Validation that is executed when minifying HTML to ensure there are no\n * unexpected errors. This is to alleviate hard-to-troubleshoot errors such as\n * undefined errors.\n */\nexport interface Validation {\n\t/**\n\t * Throws an error if <code>strategy.getPlaceholder()</code> does not return\n\t * a valid placeholder string.\n\t *\n\t * @param placeholder the placeholder to check\n\t */\n\tensurePlaceholderValid(placeholder: any): void;\n\t/**\n\t * Throws an error if <code>strategy.splitHTMLByPlaceholder()</code> does not\n\t * return an HTML part string for each template part.\n\t *\n\t * @param parts the template parts that generated the strings\n\t * @param htmlParts the split HTML strings\n\t */\n\tensureHTMLPartsValid(parts: TemplatePart[], htmlParts: string[]): void;\n}\n\n/**\n * The result of a call to <code>minifyHTMLLiterals()</code>.\n */\nexport interface Result {\n\t/**\n\t * The minified code.\n\t */\n\tcode: string;\n\t/**\n\t * Optional v3 SourceMap for the code.\n\t */\n\tmap?: SourceMap | undefined;\n}\n\n/**\n * The default method to generate a SourceMap. It will generate the SourceMap\n * from the provided MagicString instance using \"fileName.map\" as the file and\n * \"fileName\" as the source.\n *\n * @param ms the MagicString instance with code modifications\n * @param fileName the name of the source file\n * @returns a v3 SourceMap\n */\nexport function defaultGenerateSourceMap(ms: MagicStringLike, fileName: string) {\n\treturn ms.generateMap({\n\t\tfile: `${fileName}.map`,\n\t\tsource: fileName,\n\t\thires: true,\n\t});\n}\n\n/**\n * The default method to determine whether or not to minify a template. It will\n * return true for all tagged templates whose tag name contains \"html\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinify(template: Template) {\n\tconst tag = template.tag?.toLowerCase();\n\treturn !!tag && (tag.includes(\"html\") || tag.includes(\"svg\"));\n}\n\n/**\n * The default method to determine whether or not to minify a CSS template. It\n * will return true for all tagged templates whose tag name contains \"css\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinifyCSS(template: Template) {\n\tif (!template?.tag?.toLowerCase().includes(\"css\")) return false;\n\treturn true;\n}\n\n/**\n * The default validation.\n */\nexport const defaultValidation: Validation = {\n\tensurePlaceholderValid(placeholder) {\n\t\tif (typeof placeholder !== \"string\" || !placeholder.length) {\n\t\t\tthrow new Error(\"getPlaceholder() must return a non-empty string\");\n\t\t}\n\t},\n\tensureHTMLPartsValid(parts, htmlParts) {\n\t\tif (parts.length !== htmlParts.length) {\n\t\t\tthrow new Error(\"splitHTMLByPlaceholder() must return same number of strings as template parts\");\n\t\t}\n\t},\n};\n\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals(source: string, options?: DefaultOptions): Promise<Result | null>;\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals<S extends Strategy>(\n\tsource: string,\n\toptions?: CustomOptions<S>,\n): Promise<Result | null>;\n\nexport async function minifyHTMLLiterals(source: string, options: Options = {}): Promise<Result | null> {\n\toptions.MagicString = (options.MagicString || MagicString) as typeof options.MagicString;\n\toptions.parseLiterals = options.parseLiterals || parseLiterals;\n\toptions.shouldMinify = options.shouldMinify || defaultShouldMinify;\n\toptions.shouldMinifyCSS = options.shouldMinifyCSS || defaultShouldMinifyCSS;\n\n\toptions.minifyOptions = {\n\t\t...defaultMinifyOptions,\n\t\t...options.minifyOptions,\n\t};\n\n\toptions.parseLiteralsOptions = {\n\t\tfileName: options.fileName,\n\t\t...options.parseLiteralsOptions,\n\t};\n\n\tconst templates = options.parseLiterals(source, options.parseLiteralsOptions);\n\tconst strategy = <Strategy>(<CustomOptions<any>>options).strategy || defaultStrategy;\n\tconst { shouldMinify, shouldMinifyCSS } = options;\n\tlet validate: Validation | undefined;\n\tif (options.validate !== false) {\n\t\tvalidate = options.validate || defaultValidation;\n\t}\n\n\tlet skipCSS = false;\n\tlet skipHTML = false;\n\n\tif (strategy.minifyCSS && source.includes(\"unsafeCSS\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeCSS() detected in source. CSS minification will not be performed for this file.`,\n\t\t);\n\t\tskipCSS = true;\n\t}\n\n\tif (source.includes(\"unsafeHTML\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeHTML() detected in source. HTML minification will not be performed for this file.`,\n\t\t);\n\t\tskipHTML = true;\n\t}\n\n\tif (!options.MagicString) throw new Error(\"MagicString is required, this should never happen\");\n\tconst ms = new options.MagicString(source);\n\n\tconst promises = templates.map(async (template) => {\n\t\tconst minifyHTML = !skipHTML && shouldMinify(template);\n\t\tconst minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);\n\n\t\tif (!(minifyHTML || minifyCSS)) return;\n\n\t\tconst placeholder = strategy.getPlaceholder(template.parts);\n\t\tif (validate) {\n\t\t\tvalidate.ensurePlaceholderValid(placeholder);\n\t\t}\n\n\t\tconst combined = strategy.combineHTMLStrings(template.parts, placeholder);\n\t\tlet min: string;\n\n\t\tif (minifyCSS) {\n\t\t\tconst minifyCSSOptions = (options as DefaultOptions).minifyOptions?.minifyCSS;\n\t\t\tif (typeof minifyCSSOptions === \"function\") {\n\t\t\t\tmin = minifyCSSOptions(combined);\n\t\t\t} else if (minifyCSSOptions === false) {\n\t\t\t\tmin = combined;\n\t\t\t} else {\n\t\t\t\tconst cssOptions = typeof minifyCSSOptions === \"object\" ? minifyCSSOptions : undefined;\n\t\t\t\tmin = (await strategy.minifyCSS?.(combined, cssOptions)) ?? combined;\n\t\t\t}\n\t\t} else {\n\t\t\tmin = await strategy.minifyHTML(combined, options.minifyOptions);\n\t\t}\n\n\t\tconst minParts = strategy.splitHTMLByPlaceholder(min, placeholder);\n\t\tif (validate) validate.ensureHTMLPartsValid(template.parts, minParts);\n\n\t\tfor (const [index, part] of template.parts.entries()) {\n\t\t\tif (part.start < part.end)\n\t\t\t\t// Only overwrite if the literal part has text content\n\t\t\t\tms.overwrite(part.start, part.end, minParts[index] ?? \"\");\n\t\t}\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst sourceMin = ms.toString();\n\n\tif (source === sourceMin) return null;\n\n\tlet map: SourceMap | undefined;\n\tif (options.generateSourceMap !== false) {\n\t\tconst generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;\n\t\tmap = generateSourceMap(ms, options.fileName || \"\");\n\t}\n\n\treturn {\n\t\tmap,\n\t\tcode: sourceMin,\n\t};\n}\n","import CleanCSS from \"clean-css\";\nimport { type Options as HTMLOptions, minify } from \"html-minifier-terser\";\nimport type { TemplatePart } from \"parse-literals\";\n\n/**\n * A strategy on how to minify HTML and optionally CSS.\n *\n * @template O minify HTML options\n * @template C minify CSS options\n */\nexport interface Strategy<O = any, C = any> {\n\t/**\n\t * Retrieve a placeholder for the given array of template parts. The\n\t * placeholder returned should be the same if the function is invoked with the\n\t * same array of parts.\n\t *\n\t * The placeholder should be an HTML-compliant string that is not present in\n\t * any of the parts' text.\n\t *\n\t * @param parts the parts to get a placeholder for\n\t * @returns the placeholder\n\t */\n\tgetPlaceholder(parts: TemplatePart[]): string;\n\t/**\n\t * Combines the parts' HTML text strings together into a single string using\n\t * the provided placeholder. The placeholder indicates where a template\n\t * expression occurs.\n\t *\n\t * @param parts the parts to combine\n\t * @param placeholder the placeholder to use between parts\n\t * @returns the combined parts' text strings\n\t */\n\tcombineHTMLStrings(parts: TemplatePart[], placeholder: string): string;\n\t/**\n\t * Minfies the provided HTML string.\n\t *\n\t * @param html the html to minify\n\t * @param options html minify options\n\t * @returns minified HTML string\n\t */\n\tminifyHTML(html: string, options?: O): Promise<string>;\n\t/**\n\t * Minifies the provided CSS string.\n\t *\n\t * @param css the css to minfiy\n\t * @param options css minify options\n\t * @returns minified CSS string\n\t */\n\tminifyCSS?(css: string, options?: C): Promise<string>;\n\t/**\n\t * Splits a minfied HTML string back into an array of strings from the\n\t * provided placeholder. The returned array of strings should be the same\n\t * length as the template parts that were combined to make the HTML string.\n\t *\n\t * @param html the html string to split\n\t * @param placeholder the placeholder to split by\n\t * @returns an array of html strings\n\t */\n\tsplitHTMLByPlaceholder(html: string, placeholder: string): string[];\n}\n\n/**\n * The default <code>clean-css</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyCSSOptions: CleanCSS.Options = {};\n\n/**\n * The default <code>html-minifier</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyOptions: HTMLOptions = {\n\tcaseSensitive: true,\n\tcollapseWhitespace: true,\n\tdecodeEntities: true,\n\tminifyCSS: defaultMinifyCSSOptions,\n\tminifyJS: true,\n\tprocessConditionalComments: true,\n\tremoveAttributeQuotes: false,\n\tremoveComments: true,\n\tremoveEmptyAttributes: true,\n\tremoveScriptTypeAttributes: true,\n\tremoveStyleLinkTypeAttributes: true,\n\tuseShortDoctype: true,\n};\n\n/**\n * The default strategy. This uses <code>html-minifier</code> to minify HTML and\n * <code>clean-css</code> to minify CSS.\n */\nexport const defaultStrategy: Strategy<HTMLOptions, CleanCSS.Options> = {\n\tgetPlaceholder(parts) {\n\t\t// Using @ and (); will cause the expression not to be removed in CSS.\n\t\t// However, sometimes the semicolon can be removed (ex: inline styles).\n\t\t// In those cases, we want to make sure that the HTML splitting also\n\t\t// accounts for the missing semicolon.\n\t\tconst suffix = \"();\";\n\t\tlet placeholder = \"@TEMPLATE_EXPRESSION\";\n\t\twhile (parts.some((part) => part.text.includes(placeholder + suffix))) {\n\t\t\tplaceholder += \"_\";\n\t\t}\n\n\t\treturn placeholder + suffix;\n\t},\n\n\tcombineHTMLStrings(parts, placeholder) {\n\t\treturn parts.map((part) => part.text).join(placeholder);\n\t},\n\n\tasync minifyHTML(html, options = {}) {\n\t\tlet minifyCSSOptions: HTMLOptions[\"minifyCSS\"];\n\n\t\tif (html.match(/<!--(.*?)@TEMPLATE_EXPRESSION\\(\\);(.*?)-->/g)) {\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: HTML minification is not supported for template expressions inside comments. Minification for this file will be skipped.\",\n\t\t\t);\n\t\t\treturn html;\n\t\t}\n\n\t\thtml = html.replaceAll(\"<@TEMPLATE_EXPRESSION();\", \"<TEMPLATE_EXPRESSION___\");\n\t\thtml = html.replaceAll(\"</@TEMPLATE_EXPRESSION();\", \"</TEMPLATE_EXPRESSION___\");\n\n\t\tif (options.minifyCSS) {\n\t\t\tif (options.minifyCSS !== true && typeof options.minifyCSS !== \"function\") {\n\t\t\t\tminifyCSSOptions = { ...options.minifyCSS };\n\t\t\t} else {\n\t\t\t\tminifyCSSOptions = {};\n\t\t\t}\n\t\t} else {\n\t\t\tminifyCSSOptions = false;\n\t\t}\n\n\t\tlet adjustedMinifyCSSOptions: false | ReturnType<typeof adjustMinifyCSSOptions> = false;\n\t\tif (minifyCSSOptions) {\n\t\t\tadjustedMinifyCSSOptions = adjustMinifyCSSOptions(minifyCSSOptions);\n\t\t}\n\n\t\tlet result = await minify(html, {\n\t\t\t...options,\n\t\t\tminifyCSS: adjustedMinifyCSSOptions,\n\t\t});\n\n\t\tresult = result.replaceAll(\"<TEMPLATE_EXPRESSION___\", \"<@TEMPLATE_EXPRESSION();\");\n\t\tresult = result.replaceAll(\"</TEMPLATE_EXPRESSION___\", \"</@TEMPLATE_EXPRESSION();\");\n\n\t\tif (options.collapseWhitespace) {\n\t\t\t// html-minifier does not support removing newlines inside <svg>\n\t\t\t// attributes. Support this, but be careful not to remove newlines from\n\t\t\t// supported areas (such as within <pre> and <textarea> tags).\n\t\t\tconst matches = Array.from(result.matchAll(/<svg/g)).reverse();\n\t\t\tfor (const match of matches) {\n\t\t\t\tconst startTagIndex = match.index ?? 0;\n\t\t\t\tconst closeTagIndex = result.indexOf(\"</svg\", startTagIndex);\n\t\t\t\tif (closeTagIndex < 0) {\n\t\t\t\t\t// Malformed SVG without a closing tag\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst start = result.substring(0, startTagIndex);\n\t\t\t\tlet svg = result.substring(startTagIndex, closeTagIndex);\n\t\t\t\tconst end = result.substring(closeTagIndex);\n\t\t\t\tsvg = svg.replace(/\\r?\\n/g, \"\");\n\t\t\t\tresult = start + svg + end;\n\t\t\t}\n\t\t}\n\t\tresult = fixCleanCssTidySelectors(html, result);\n\n\t\treturn result;\n\t},\n\tasync minifyCSS(css, options = {}) {\n\t\tconst adjustedOptions = adjustMinifyCSSOptions(options);\n\n\t\tcss = css.replaceAll(/@TEMPLATE_EXPRESSION\\(\\);:/g, \"--TEMPLATE-EXPRESSION:\");\n\t\tconst output = await new CleanCSS({\n\t\t\t...adjustedOptions,\n\t\t\treturnPromise: true,\n\t\t}).minify(css);\n\n\t\tif (output.errors?.length) throw new Error(output.errors.join(\"\\n\\n\"));\n\n\t\t// If there are warnings, return the unminified CSS.\n\t\t// CleanCSS can sometimes struggle with our preprocessed CSS due to the replaced template expressions.\n\t\tif (output.warnings?.length) console.log(css, output.styles);\n\t\tif (output.warnings.length) {\n\t\t\tconsole.warn(output.warnings.join(\"\\n\\n\"));\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: warnings during CSS minification, file was skipped. See above for details.\",\n\t\t\t);\n\t\t\treturn css.replace(/(\\n)|(\\r)/g, \"\");\n\t\t}\n\n\t\toutput.styles = output.styles.replaceAll(\"--TEMPLATE-EXPRESSION:\", \"@TEMPLATE_EXPRESSION();:\");\n\t\toutput.styles = fixCleanCssTidySelectors(css, output.styles);\n\t\treturn output.styles;\n\t},\n\tsplitHTMLByPlaceholder(html, placeholder) {\n\t\tconst parts = html.split(placeholder);\n\t\t// Make the last character (a semicolon) optional. See above.\n\t\tif (placeholder.endsWith(\";\")) {\n\t\t\tconst withoutSemicolon = placeholder.substring(0, placeholder.length - 1);\n\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\tparts.splice(i, 1, ...(parts[i]?.split(withoutSemicolon) ?? []));\n\t\t\t}\n\t\t}\n\n\t\treturn parts;\n\t},\n};\n\nexport function adjustMinifyCSSOptions(options: CleanCSS.Options = {}) {\n\tconst level = options.level;\n\n\tconst plugin = {\n\t\tlevel1: {\n\t\t\tvalue: (_name: any, value: string) => {\n\t\t\t\tif (!value.startsWith(\"@TEMPLATE_EXPRESSION\") || value.endsWith(\";\")) return value;\n\n\t\t\t\t// The CSS minifier has removed the semicolon from the placeholder\n\t\t\t\t// and we need to add it back.\n\t\t\t\treturn `${value};`;\n\t\t\t},\n\t\t},\n\t};\n\n\treturn {\n\t\t...options,\n\t\tlevel,\n\t\tplugins: [plugin],\n\t};\n}\n\n// Should be fixed in clean-css https://github.com/clean-css/clean-css/issues/996, but is still happening\nfunction fixCleanCssTidySelectors(original: string, result: string) {\n\tconst regex = /(::?.+\\((.*)\\))[\\s\\r\\n]*{/gm;\n\tlet match: RegExpMatchArray | null;\n\t// biome-ignore lint/suspicious/noAssignInExpressions: this is fine\n\twhile ((match = regex.exec(original)) != null) {\n\t\tconst pseudoClass = match[1] ?? \"\";\n\t\tconst parameters = match[2];\n\n\t\tif (!parameters?.match(/\\s/)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parametersWithoutSpaces = parameters.replace(/\\s/g, \"\");\n\t\tconst resultPseudoClass = pseudoClass.replace(parameters, parametersWithoutSpaces);\n\t\tconst resultStartIndex = result.indexOf(resultPseudoClass);\n\t\tif (resultStartIndex < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst resultEndIndex = resultStartIndex + resultPseudoClass.length;\n\t\t// Restore the original pseudo class with spaces\n\t\tresult = result.substring(0, resultStartIndex) + pseudoClass + result.substring(resultEndIndex);\n\t}\n\n\treturn result;\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../lib/index.ts","../lib/strategy.ts"],"sourcesContent":["import MagicString, { type SourceMapOptions } from \"magic-string\";\nimport { type Template, type TemplatePart, type ParseLiteralsOptions, parseLiterals } from \"parse-literals\";\nimport { type Strategy, defaultMinifyOptions, defaultStrategy } from \"./strategy.js\";\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport type Options = DefaultOptions | CustomOptions<any>;\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using default html-minifier\n * strategy.\n */\nexport interface DefaultOptions extends BaseOptions {\n\t/**\n\t * <code>html-minifier</code> options to use. Defaults to\n\t * <code>defaultMinifyOptions</code>, for production-ready minification.\n\t */\n\tminifyOptions?: Partial<typeof defaultMinifyOptions>;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using a custom strategy.\n */\nexport interface CustomOptions<S extends Strategy> extends BaseOptions {\n\t/**\n\t * HTML minification options.\n\t */\n\tminifyOptions?: S extends Strategy<infer O> ? Partial<O> : never;\n\t/**\n\t * Override the default strategy for how to minify HTML. The default is to\n\t * use <code>html-minifier</code>.\n\t */\n\tstrategy: S;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport interface BaseOptions {\n\t/**\n\t * The name of the file. This is used to determine how to parse the source\n\t * code and for source map filenames. It may be a base name, relative, or\n\t * absolute path.\n\t */\n\tfileName?: string;\n\t/**\n\t * Override how source maps are generated. Set to false to disable source map\n\t * generation.\n\t *\n\t * @param ms the MagicString instance with code modifications\n\t * @param fileName the name or path of the file\n\t * @returns a v3 SourceMap or undefined\n\t */\n\tgenerateSourceMap?: ((ms: MagicStringLike, fileName: string) => SourceMap | undefined) | false;\n\t/**\n\t * The MagicString-like constructor to use. MagicString is used to replace\n\t * strings and generate source maps.\n\t *\n\t * Override if you want to set your own version of MagicString or change how\n\t * strings are overridden. Use <code>generateSourceMap</code> if you want to\n\t * change how source maps are created.\n\t */\n\tMagicString?: { new (source: string): MagicStringLike };\n\t/**\n\t * Override how template literals are parsed from a source string.\n\t */\n\tparseLiterals?: typeof parseLiterals;\n\t/**\n\t * Options for <code>parseLiterals()</code>.\n\t */\n\tparseLiteralsOptions?: Partial<ParseLiteralsOptions>;\n\t/**\n\t * Determines whether or not a template should be minified. The default is to\n\t * minify all tagged template whose tag name contains \"html\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinify?(template: Template): boolean;\n\t/**\n\t * Determines whether or not a CSS template should be minified. The default is\n\t * to minify all tagged template whose tag name contains \"css\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinifyCSS?(template: Template): boolean;\n\t/**\n\t * Override custom validation or set to false to disable validation. This is\n\t * only useful when implementing your own strategy that may return\n\t * unexpected results.\n\t */\n\tvalidate?: Validation | false;\n}\n\n/**\n * A MagicString-like instance. <code>minify-literals</code> only uses a\n * subset of the MagicString API to overwrite the source code and generate\n * source maps.\n */\nexport interface MagicStringLike {\n\tgenerateMap(options?: Partial<SourceMapOptions>): SourceMap;\n\toverwrite(start: number, end: number, content: string): any;\n\ttoString(): string;\n}\n\n/**\n * A v3 SourceMap.\n *\n * <code>magic-string> incorrectly declares the SourceMap type with a version\n * string instead of a number, so <code>minify-literals</code> declares\n * its own type.\n */\nexport interface SourceMap {\n\tversion: number | string;\n\tfile: string | null;\n\tsources: Array<string | null>;\n\tsourcesContent: Array<string | null>;\n\tnames: string[];\n\tmappings: string;\n\ttoString(): string;\n\ttoUrl(): string;\n}\n\n/**\n * Validation that is executed when minifying HTML to ensure there are no\n * unexpected errors. This is to alleviate hard-to-troubleshoot errors such as\n * undefined errors.\n */\nexport interface Validation {\n\t/**\n\t * Throws an error if <code>strategy.getPlaceholder()</code> does not return\n\t * a valid placeholder string.\n\t *\n\t * @param placeholder the placeholder to check\n\t */\n\tensurePlaceholderValid(placeholder: any): void;\n\t/**\n\t * Throws an error if <code>strategy.splitHTMLByPlaceholder()</code> does not\n\t * return an HTML part string for each template part.\n\t *\n\t * @param parts the template parts that generated the strings\n\t * @param htmlParts the split HTML strings\n\t */\n\tensureHTMLPartsValid(parts: TemplatePart[], htmlParts: string[]): void;\n}\n\n/**\n * The result of a call to <code>minifyHTMLLiterals()</code>.\n */\nexport interface Result {\n\t/**\n\t * The minified code.\n\t */\n\tcode: string;\n\t/**\n\t * Optional v3 SourceMap for the code.\n\t */\n\tmap?: SourceMap | undefined;\n}\n\n/**\n * The default method to generate a SourceMap. It will generate the SourceMap\n * from the provided MagicString instance using \"fileName.map\" as the file and\n * \"fileName\" as the source.\n *\n * @param ms the MagicString instance with code modifications\n * @param fileName the name of the source file\n * @returns a v3 SourceMap\n */\nexport function defaultGenerateSourceMap(ms: MagicStringLike, fileName: string) {\n\treturn ms.generateMap({\n\t\tfile: `${fileName}.map`,\n\t\tsource: fileName,\n\t\thires: true,\n\t});\n}\n\n/**\n * The default method to determine whether or not to minify a template. It will\n * return true for all tagged templates whose tag name contains \"html\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinify(template: Template) {\n\tconst tag = template.tag?.toLowerCase();\n\treturn !!tag && (tag.includes(\"html\") || tag.includes(\"svg\"));\n}\n\n/**\n * The default method to determine whether or not to minify a CSS template. It\n * will return true for all tagged templates whose tag name contains \"css\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinifyCSS(template: Template) {\n\tif (!template?.tag?.toLowerCase().includes(\"css\")) return false;\n\treturn true;\n}\n\n/**\n * The default validation.\n */\nexport const defaultValidation: Validation = {\n\tensurePlaceholderValid(placeholder) {\n\t\tif (typeof placeholder === \"string\" && placeholder.length > 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (Array.isArray(placeholder) && placeholder.every((ph) => ph.length > 0)) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(\"getPlaceholder() must return a non-empty string | string[]\");\n\t},\n\tensureHTMLPartsValid(parts, htmlParts) {\n\t\tif (parts.length !== htmlParts.length) {\n\t\t\tthrow new Error(\"splitHTMLByPlaceholder() must return same number of strings as template parts\");\n\t\t}\n\t},\n};\n\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals(source: string, options?: DefaultOptions): Promise<Result | null>;\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals<S extends Strategy>(\n\tsource: string,\n\toptions?: CustomOptions<S>,\n): Promise<Result | null>;\n\nexport async function minifyHTMLLiterals(source: string, options: Options = {}): Promise<Result | null> {\n\toptions.MagicString = (options.MagicString || MagicString) as typeof options.MagicString;\n\toptions.parseLiterals = options.parseLiterals || parseLiterals;\n\toptions.shouldMinify = options.shouldMinify || defaultShouldMinify;\n\toptions.shouldMinifyCSS = options.shouldMinifyCSS || defaultShouldMinifyCSS;\n\n\toptions.minifyOptions = {\n\t\t...defaultMinifyOptions,\n\t\t...options.minifyOptions,\n\t};\n\n\toptions.parseLiteralsOptions = {\n\t\tfileName: options.fileName,\n\t\t...options.parseLiteralsOptions,\n\t};\n\n\tconst templates = options.parseLiterals(source, options.parseLiteralsOptions);\n\tconst strategy = <Strategy>(<CustomOptions<any>>options).strategy || defaultStrategy;\n\tconst { shouldMinify, shouldMinifyCSS } = options;\n\tlet validate: Validation | undefined;\n\tif (options.validate !== false) {\n\t\tvalidate = options.validate || defaultValidation;\n\t}\n\n\tlet skipCSS = false;\n\tlet skipHTML = false;\n\n\tif (strategy.minifyCSS && source.includes(\"unsafeCSS\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeCSS() detected in source. CSS minification will not be performed for this file.`,\n\t\t);\n\t\tskipCSS = true;\n\t}\n\n\tif (source.includes(\"unsafeHTML\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeHTML() detected in source. HTML minification will not be performed for this file.`,\n\t\t);\n\t\tskipHTML = true;\n\t}\n\n\tif (!options.MagicString) throw new Error(\"MagicString is required, this should never happen\");\n\tconst ms = new options.MagicString(source);\n\n\tconst promises = templates.map(async (template) => {\n\t\tconst minifyHTML = !skipHTML && shouldMinify(template);\n\t\tconst minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);\n\n\t\tif (!(minifyHTML || minifyCSS)) return;\n\n\t\tconst placeholder = strategy.getPlaceholder(template.parts, template.tag);\n\t\tif (validate) {\n\t\t\tvalidate.ensurePlaceholderValid(placeholder);\n\t\t}\n\n\t\tconst combined = strategy.combineHTMLStrings(template.parts, placeholder);\n\t\tlet min: string;\n\n\t\tif (minifyCSS) {\n\t\t\tconst minifyCSSOptions = (options as DefaultOptions).minifyOptions?.minifyCSS;\n\t\t\tif (typeof minifyCSSOptions === \"function\") {\n\t\t\t\tmin = minifyCSSOptions(combined);\n\t\t\t} else if (minifyCSSOptions === false) {\n\t\t\t\tmin = combined;\n\t\t\t} else {\n\t\t\t\tconst cssOptions = typeof minifyCSSOptions === \"object\" ? minifyCSSOptions : undefined;\n\t\t\t\tmin = (await strategy.minifyCSS?.(combined, cssOptions)) ?? combined;\n\t\t\t}\n\t\t} else {\n\t\t\tmin = await strategy.minifyHTML(combined, options.minifyOptions);\n\t\t}\n\n\t\tconst minParts = strategy.splitHTMLByPlaceholder(min, placeholder);\n\t\tif (validate) validate.ensureHTMLPartsValid(template.parts, minParts);\n\n\t\tfor (const [index, part] of template.parts.entries()) {\n\t\t\tif (part.start < part.end)\n\t\t\t\t// Only overwrite if the literal part has text content\n\t\t\t\tms.overwrite(part.start, part.end, minParts[index] ?? \"\");\n\t\t}\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst sourceMin = ms.toString();\n\n\tif (source === sourceMin) return null;\n\n\tlet map: SourceMap | undefined;\n\tif (options.generateSourceMap !== false) {\n\t\tconst generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;\n\t\tmap = generateSourceMap(ms, options.fileName || \"\");\n\t}\n\n\treturn {\n\t\tmap,\n\t\tcode: sourceMin,\n\t};\n}\n","import CleanCSS from \"clean-css\";\nimport { type Options as HTMLOptions, minify } from \"html-minifier-terser\";\nimport type { TemplatePart } from \"parse-literals\";\nimport { randomBytes, randomInt } from \"node:crypto\";\n\n/**\n * A strategy on how to minify HTML and optionally CSS.\n *\n * @template O minify HTML options\n * @template C minify CSS options\n */\nexport interface Strategy<O = any, C = any> {\n\t/**\n\t * Retrieve a placeholder for the given array of template parts. The\n\t * placeholder returned should be the same if the function is invoked with the\n\t * same array of parts.\n\t *\n\t * The placeholder should be an HTML-compliant string that is not present in\n\t * any of the parts' text.\n\t *\n\t * @param parts the parts to get a placeholder for\n\t * @returns the placeholder\n\t */\n\tgetPlaceholder(parts: TemplatePart[], tag?: string): string | string[];\n\t/**\n\t * Combines the parts' HTML text strings together into a single string using\n\t * the provided placeholder. The placeholder indicates where a template\n\t * expression occurs.\n\t *\n\t * @param parts the parts to combine\n\t * @param placeholder the placeholder to use between parts\n\t * @returns the combined parts' text strings\n\t */\n\tcombineHTMLStrings(parts: TemplatePart[], placeholder: string | string[]): string;\n\t/**\n\t * Minfies the provided HTML string.\n\t *\n\t * @param html the html to minify\n\t * @param options html minify options\n\t * @returns minified HTML string\n\t */\n\tminifyHTML(html: string, options?: O): Promise<string>;\n\t/**\n\t * Minifies the provided CSS string.\n\t *\n\t * @param css the css to minfiy\n\t * @param options css minify options\n\t * @returns minified CSS string\n\t */\n\tminifyCSS?(css: string, options?: C): Promise<string>;\n\t/**\n\t * Splits a minfied HTML string back into an array of strings from the\n\t * provided placeholder. The returned array of strings should be the same\n\t * length as the template parts that were combined to make the HTML string.\n\t *\n\t * @param html the html string to split\n\t * @param placeholder the placeholder to split by\n\t * @returns an array of html strings\n\t */\n\tsplitHTMLByPlaceholder(html: string, placeholder: string | string[]): string[];\n}\n\n/**\n * The default <code>clean-css</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyCSSOptions: CleanCSS.Options = {};\n\n/**\n * The default <code>html-minifier</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyOptions: HTMLOptions = {\n\tcaseSensitive: true,\n\tcollapseWhitespace: true,\n\tdecodeEntities: true,\n\tminifyCSS: defaultMinifyCSSOptions,\n\tminifyJS: true,\n\tprocessConditionalComments: true,\n\tremoveAttributeQuotes: false,\n\tremoveComments: true,\n\tremoveEmptyAttributes: true,\n\tremoveScriptTypeAttributes: true,\n\tremoveStyleLinkTypeAttributes: true,\n\tuseShortDoctype: true,\n};\n\n/**\n * The default strategy. This uses <code>html-minifier</code> to minify HTML and\n * <code>clean-css</code> to minify CSS.\n */\nexport const defaultStrategy: Strategy<HTMLOptions, CleanCSS.Options> = {\n\tgetPlaceholder(parts, tag) {\n\t\tconst isCss = tag?.toLowerCase().includes(\"css\");\n\t\tif (isCss) {\n\t\t\t// use strict mode to avoid issues with CSS minification\n\t\t\tconst random = `tmp_${randomBytes(6).toString(\"hex\")}`;\n\t\t\tconst placeholder: string[] = [];\n\t\t\tconst comment = /\\/\\*[\\s\\S]*?\\*\\//g;\n\t\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\t\tconst beforeFull = parts[i - 1]!.text;\n\t\t\t\tconst beforeCss = beforeFull.replace(comment, \"\");\n\t\t\t\tconst afterFull = parts[i]!.text;\n\t\t\t\tconst afterCss = afterFull.replace(comment, \"\");\n\t\t\t\t/**\n\t\t\t\t * 1. selector\n\t\t\t\t * ${selector} {\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 2. key\n\t\t\t\t * selector {\n\t\t\t\t * \t ${key}: value;\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 3. rule\n\t\t\t\t * [selector {}]\n\t\t\t\t * ${rule}\n\t\t\t\t * [selector {}]\n\t\t\t\t *\n\t\t\t\t * 4. number-literal\n\t\t\t\t * selector{\n\t\t\t\t *   key: ${param}px;\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 5. value\n\t\t\t\t * selector {\n\t\t\t\t * \t key: ${value};\n\t\t\t\t * \t key: ${value}\n\t\t\t\t * }\n\t\t\t\t *\n\t\t\t\t * 6. param\n\t\t\t\t * selector{\n\t\t\t\t *   key: fun(${param}[, ${param}]);\n\t\t\t\t * }\n\t\t\t\t */\n\n\t\t\t\tconst isSelector = /^\\s*\\{/.test(afterCss);\n\t\t\t\tif (isSelector) {\n\t\t\t\t\tplaceholder.push(`#${random}`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst isKey = /^\\s*:/.test(afterCss);\n\t\t\t\tif (isKey) {\n\t\t\t\t\tplaceholder.push(`--${random}`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst isRule = /\\}\\s*$/.test(beforeCss) || beforeCss.trim().length === 0;\n\t\t\t\tif (isRule) {\n\t\t\t\t\treturn `@${random}();`;\n\t\t\t\t}\n\t\t\t\tconst isUnit = /^\\w+/.test(afterCss);\n\t\t\t\tif (isUnit) {\n\t\t\t\t\tlet num: string;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tnum = `${randomInt(281474976710655)}`;\n\t\t\t\t\t\tif (!beforeFull.includes(num)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tplaceholder.push(num);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst isValue = /:\\s*$/.test(beforeCss);\n\t\t\t\tif (isValue) {\n\t\t\t\t\tplaceholder.push(`var(--${random})`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// isParams\n\t\t\t\tplaceholder.push(`var(--${random})`);\n\t\t\t}\n\t\t\treturn placeholder;\n\t\t}\n\t\t// Using @ and (); will cause the expression not to be removed in CSS.\n\t\t// However, sometimes the semicolon can be removed (ex: inline styles).\n\t\t// In those cases, we want to make sure that the HTML splitting also\n\t\t// accounts for the missing semicolon.\n\t\tconst suffix = \"();\";\n\t\tlet placeholder = \"@TEMPLATE_EXPRESSION\";\n\t\twhile (parts.some((part) => part.text.includes(placeholder + suffix))) {\n\t\t\tplaceholder += \"_\";\n\t\t}\n\n\t\treturn placeholder + suffix;\n\t},\n\n\tcombineHTMLStrings(parts, placeholder) {\n\t\tif (typeof placeholder === \"string\") {\n\t\t\treturn parts.map((part) => part.text).join(placeholder);\n\t\t}\n\t\treturn parts.map((part, i) => part.text + (placeholder[i] ?? \"\")).join(\"\");\n\t},\n\n\tasync minifyHTML(html, options = {}) {\n\t\tlet minifyCSSOptions: HTMLOptions[\"minifyCSS\"];\n\n\t\tif (html.match(/<!--(.*?)@TEMPLATE_EXPRESSION\\(\\);(.*?)-->/g)) {\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: HTML minification is not supported for template expressions inside comments. Minification for this file will be skipped.\",\n\t\t\t);\n\t\t\treturn html;\n\t\t}\n\n\t\thtml = html.replaceAll(\"<@TEMPLATE_EXPRESSION();\", \"<TEMPLATE_EXPRESSION___\");\n\t\thtml = html.replaceAll(\"</@TEMPLATE_EXPRESSION();\", \"</TEMPLATE_EXPRESSION___\");\n\n\t\tif (options.minifyCSS) {\n\t\t\tif (options.minifyCSS !== true && typeof options.minifyCSS !== \"function\") {\n\t\t\t\tminifyCSSOptions = { ...options.minifyCSS };\n\t\t\t} else {\n\t\t\t\tminifyCSSOptions = {};\n\t\t\t}\n\t\t} else {\n\t\t\tminifyCSSOptions = false;\n\t\t}\n\n\t\tlet adjustedMinifyCSSOptions: false | ReturnType<typeof adjustMinifyCSSOptions> = false;\n\t\tif (minifyCSSOptions) {\n\t\t\tadjustedMinifyCSSOptions = adjustMinifyCSSOptions(minifyCSSOptions);\n\t\t}\n\n\t\tlet result = await minify(html, {\n\t\t\t...options,\n\t\t\tminifyCSS: adjustedMinifyCSSOptions,\n\t\t});\n\n\t\tresult = result.replaceAll(\"<TEMPLATE_EXPRESSION___\", \"<@TEMPLATE_EXPRESSION();\");\n\t\tresult = result.replaceAll(\"</TEMPLATE_EXPRESSION___\", \"</@TEMPLATE_EXPRESSION();\");\n\n\t\tif (options.collapseWhitespace) {\n\t\t\t// html-minifier does not support removing newlines inside <svg>\n\t\t\t// attributes. Support this, but be careful not to remove newlines from\n\t\t\t// supported areas (such as within <pre> and <textarea> tags).\n\t\t\tconst matches = Array.from(result.matchAll(/<svg/g)).reverse();\n\t\t\tfor (const match of matches) {\n\t\t\t\tconst startTagIndex = match.index ?? 0;\n\t\t\t\tconst closeTagIndex = result.indexOf(\"</svg\", startTagIndex);\n\t\t\t\tif (closeTagIndex < 0) {\n\t\t\t\t\t// Malformed SVG without a closing tag\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst start = result.substring(0, startTagIndex);\n\t\t\t\tlet svg = result.substring(startTagIndex, closeTagIndex);\n\t\t\t\tconst end = result.substring(closeTagIndex);\n\t\t\t\tsvg = svg.replace(/\\r?\\n/g, \"\");\n\t\t\t\tresult = start + svg + end;\n\t\t\t}\n\t\t}\n\t\tresult = fixCleanCssTidySelectors(html, result);\n\n\t\treturn result;\n\t},\n\tasync minifyCSS(css, options = {}) {\n\t\tconst adjustedOptions = adjustMinifyCSSOptions(options);\n\n\t\tcss = css.replaceAll(/@TEMPLATE_EXPRESSION\\(\\);:/g, \"--TEMPLATE-EXPRESSION:\");\n\t\tconst output = await new CleanCSS({\n\t\t\t...adjustedOptions,\n\t\t\treturnPromise: true,\n\t\t}).minify(css);\n\n\t\tif (output.errors?.length) throw new Error(output.errors.join(\"\\n\\n\"));\n\n\t\t// If there are warnings, return the unminified CSS.\n\t\t// CleanCSS can sometimes struggle with our preprocessed CSS due to the replaced template expressions.\n\t\tif (output.warnings?.length) console.log(css, output.styles);\n\t\tif (output.warnings.length) {\n\t\t\tconsole.warn(output.warnings.join(\"\\n\\n\"));\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: warnings during CSS minification, file was skipped. See above for details.\",\n\t\t\t);\n\t\t\treturn css.replace(/(\\n)|(\\r)/g, \"\");\n\t\t}\n\n\t\toutput.styles = output.styles.replaceAll(\"--TEMPLATE-EXPRESSION:\", \"@TEMPLATE_EXPRESSION();:\");\n\t\toutput.styles = fixCleanCssTidySelectors(css, output.styles);\n\t\treturn output.styles;\n\t},\n\tsplitHTMLByPlaceholder(html, placeholder) {\n\t\tlet parts: string[];\n\t\tif (typeof placeholder === \"string\") {\n\t\t\tparts = html.split(placeholder);\n\t\t\t// Make the last character (a semicolon) optional. See above.\n\t\t\tif (placeholder.endsWith(\";\")) {\n\t\t\t\tconst withoutSemicolon = placeholder.substring(0, placeholder.length - 1);\n\t\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\t\tparts.splice(i, 1, ...(parts[i]?.split(withoutSemicolon) ?? []));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tparts = [];\n\t\t\t// strice mode\n\t\t\tlet pos = 0;\n\t\t\tlet index = -1;\n\t\t\tfor (const ph of placeholder) {\n\t\t\t\tindex = html.indexOf(ph, pos);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tthrow new Error(`placeholder ${ph} not found in html ${html}`);\n\t\t\t\t}\n\t\t\t\tparts.push(html.slice(pos, index));\n\t\t\t\tpos = index + ph.length;\n\t\t\t}\n\t\t\tparts.push(html.slice(pos));\n\t\t}\n\n\t\treturn parts;\n\t},\n};\n\nexport function adjustMinifyCSSOptions(options: CleanCSS.Options = {}) {\n\tconst level = options.level;\n\n\tconst plugin = {\n\t\tlevel1: {\n\t\t\tvalue: (_name: any, value: string) => {\n\t\t\t\tif (!value.startsWith(\"@TEMPLATE_EXPRESSION\") || value.endsWith(\";\")) return value;\n\n\t\t\t\t// The CSS minifier has removed the semicolon from the placeholder\n\t\t\t\t// and we need to add it back.\n\t\t\t\treturn `${value};`;\n\t\t\t},\n\t\t},\n\t};\n\n\treturn {\n\t\t...options,\n\t\tlevel,\n\t\tplugins: [plugin],\n\t};\n}\n\n// Should be fixed in clean-css https://github.com/clean-css/clean-css/issues/996, but is still happening\nfunction fixCleanCssTidySelectors(original: string, result: string) {\n\tconst regex = /(::?.+\\((.*)\\))[\\s\\r\\n]*{/gm;\n\tlet match: RegExpMatchArray | null;\n\t// biome-ignore lint/suspicious/noAssignInExpressions: this is fine\n\twhile ((match = regex.exec(original)) != null) {\n\t\tconst pseudoClass = match[1] ?? \"\";\n\t\tconst parameters = match[2];\n\n\t\tif (!parameters?.match(/\\s/)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parametersWithoutSpaces = parameters.replace(/\\s/g, \"\");\n\t\tconst resultPseudoClass = pseudoClass.replace(parameters, parametersWithoutSpaces);\n\t\tconst resultStartIndex = result.indexOf(resultPseudoClass);\n\t\tif (resultStartIndex < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst resultEndIndex = resultStartIndex + resultPseudoClass.length;\n\t\t// Restore the original pseudo class with spaces\n\t\tresult = result.substring(0, resultStartIndex) + pseudoClass + result.substring(resultEndIndex);\n\t}\n\n\treturn result;\n}\n"],"mappings":"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","names":["placeholder"]}
